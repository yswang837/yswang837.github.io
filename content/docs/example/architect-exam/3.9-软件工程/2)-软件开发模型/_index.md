# 软件开发模型 ✌

&emsp;&emsp;一个开发方法（方法论）下面可以有多个开发模型。各种开发模型之间是存在重合和交叠的，而不是完全隔离的。

## 1 瀑布模型

---

&emsp;&emsp;严格先后完成每个阶段，上一阶段的输出时下一个阶段的输入，是结构化开发方法的典型模型，适合于**需求明确**的项目，对大型项目来说风险较大。

[![p9TxwTA.md.png](https://s1.ax1x.com/2023/05/24/p9TxwTA.md.png)](https://imgse.com/i/p9TxwTA)

## 2 迭代/演化模型

---

&emsp;&emsp;先快速开发出一个能用的丐版模型，之后再进行完善和优化，每一轮迭代均发布一个可用的产品。

[![p97uiGT.md.png](https://s1.ax1x.com/2023/05/24/p97uiGT.md.png)](https://imgse.com/i/p97uiGT)

## 3 增量模型

---

&emsp;&emsp;先开发出最核心的组件，之后在再核心组件上开发出别的组件，每一次增量均发布一个可用的产品。增量式模型相比于瀑布模型的优点有：降低了适应用户需求变更的成本。

[![p97u9I0.png](https://s1.ax1x.com/2023/05/24/p97u9I0.png)](https://imgse.com/i/p97u9I0)

## 4 螺旋模型

---

&emsp;&emsp;螺旋模型 = 原型 + 瀑布模型，首次引入**风险分析**，适合大型项目，螺旋模型是在快速模型的基础上扩展而成的。

&emsp;&emsp;螺旋模型将整个软件开发过程分为多个阶段，每个阶段都由目标设定、风险分析、开发和有效性验证以及评审4个部分组成。

[![p97urQg.md.png](https://s1.ax1x.com/2023/05/24/p97urQg.md.png)](https://imgse.com/i/p97urQg)

>例题
[![pCNJCLD.md.png](https://s1.ax1x.com/2023/06/25/pCNJCLD.md.png)](https://imgse.com/i/pCNJCLD)
{{< expand "学霸肯定对了">}}B{{< /expand >}}

## 5 原型模型

---

&emsp;&emsp;适合需求不明确的系统。若题目中指明“需求不明确”，选原型而不选螺旋模型。

## 6 喷泉模型

---

&emsp;&emsp;早期著名的面向对象模型。它的特点是各个阶段之间没有明显的界限（区别于瀑布模型），各个阶段可以并发；但它非常不利于项目管理。

[![p97u2oq.png](https://s1.ax1x.com/2023/05/24/p97u2oq.png)](https://imgse.com/i/p97u2oq)

## 7 V模型

---

&emsp;&emsp;测试提前做，测试贯穿于始终。

[![p97uces.md.png](https://s1.ax1x.com/2023/05/24/p97uces.md.png)](https://imgse.com/i/p97uces)

## 8 构建组装模型

---

&emsp;&emsp;优点：快，成本低、可靠高、构件是一个独立可交付的单元，构件外部通过接口访问构件提供的服务。

&emsp;&emsp;缺点：构建库的建立需要慢慢积累。放到个人来说就是，代码库的建立需要慢慢积累。

&emsp;&emsp;软件系统通过构件组装分为三个不同的层次:定制(customization)、集成(integration)和扩展 (extension)。

&emsp;&emsp;基于构建的开发模型：需求分析和定义->软件架构设计->构件库的建立->应用软件构建->测试和发布。

&emsp;&emsp;为了被广泛的使用，接口同构建一样也有规范；接口标准化是对接口中的消息模式、格式和协议的标准化。

&emsp;&emsp;J2EE应用系统支持5种不同类型的构建模型，分别是：Applet、Servlet、JSP、**EJB**、Application Client。其中EJB是企业级Java构件，用于开发和部署多层结构的、分布式的、面向对象的Java应用系统。其中，**会话型构件**负责完成服务端与客户端的交互;**实体型构件**用于数据持久化来简化数据库开发工作;**消息驱动构件**主要用来处理并发和异步访问操作。COM+可用于开发适用于Windows的企业范围、任务关键型分布式应用程序。ASP即Active Server Pages，是Microsoft公司开发的服务器端脚本环境，可用来创建动态交互式网页并建立强大的web应用程序。

&emsp;&emsp;CORBA标准中，OMG接口定义语言IDL文件包含了六种不同的元素，包括模块定义、类型定义、常量定义、异常、接口描述和值类型，其中，**接口描述是一个IDL文件最核心的内容**，**模块定义**将被映射为Java语言中的**包**和C++语言中的**命名空间**。CORBA服务端构建模型中，**伺服对象(Servant)**是CORBA对象的**真正实现**，负责完成客户端请求，**可移植对象适配器POA**的作用是**在底层传输平台与接收调用并返回结果的对象实现之间进行协调**。COM支持两种形式的对象组装:包含(Containment，是一个对象拥有指向另一个对象的唯一引用)和聚集(Aggregation，直接把内部对象接口用传给外部对象的客户，而不是再转发请求)。

&emsp;&emsp;对象管理组织(OMG)基于CORBA基础设施定义了4种构件标准：**实体(Entity)构件**需要长期持久化并主要用于事务性行为，由容器管理其持久化。**加工(Process)构件**同样需要容器管理其持久化，但没有客户端可访问的主键。**会话(Session)构件**不需要容器管理其持久化，其状态信息必须由构件自己管理。**服务(Service)构件**是无状态的。

&emsp;&emsp;基于构件的软件开发中，已有的构建分类方法可以归纳为三大类：**关键字分类法**(根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构)；**刻面分类法**(利用刻面Facet描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征)；**超文本方法**(基于全文检索技术，使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档)。

&emsp;&emsp;如果把软件系统看成是构件的集合，那么从构件的外部形态来看，构成一个系统的构件可分为五类：**独立而成熟的构件**得到了实际运行环境的多次检验，**有限制的构件**提供了接口，指出了使用的条件和前提，**适应性构件**进行了包装或使用了接口技术，把不兼容性、资源冲突等进行了处理，可以直接使用，**装配的构件**在安装时，已经装配在操作系统、数据库管理系统或信息系统不同层次上，可以连续使用;**可修改的构件**可以进行版本替换，如果对原构件修改错误、增加新功能，可以利用重新“包装”或写接口来实现构件的替换。

&emsp;&emsp;构件组装是将库中的构件经适当修改后相互连接，或者将它们与当前开发项目中的软件元素相连接，最终构成新的目标软件。构件组装技术大致可分为**基于功能的组装技术、基于数据的组装技术和面向对象的组装技术**。

&emsp;&emsp;软件构件是一个独立可部署的软件单元，与程序设计中的对象不同，构件可以利用容器管理自身对外的可见状态

&emsp;&emsp;软件重用可以区别为横向重用和纵向重用。横向重用是指重用不同应用领域中的软件元素，例如标准库函数、数据结构、分类算法和人机界面构建等。纵向重用是指在类具有较多公共性的应用领域之间进行软部件重用。纵向重用活动的主要关键点是领域分析:根据应用领域的特征及相似性预测软部件的可重用性。软件重用的元素包括：需求分析文档、设计文档、程序代码、测试用例和领域知识。

&emsp;&emsp;在基于构件的软件开发中，**逻辑构件模型**用功能描述系统的抽象设计，用接口描述每个服务集合以及功能之间如何交互以满足用户需求，它作为系统的设计蓝图以保证系统提供适当的功能。**物理构件模型**用技术设施产品、硬件分布和拓扑结构，以及用于绑定的网络和通信协议描述系统的物理设计，这种架构用于了解系统的性能、吞吐率等许多非功能性属性。

&emsp;&emsp;在构件组装过程中需要检测并解决架构失配问题。其中构建失配主要包括由于系统对构件基础设施、控制模型和数据模型的假设存在冲突引起的失配。连接子失配包括由手系统对构件交互协议、构件连接时数据格式的假设存在冲突引起的失配。

&emsp;&emsp;面向构件的编程(Component Oriented Programming,COP)关注于如何支持建立面向构件的解决方案。面向构件的编程所需要的基本支持包括多态性、模块封装性、后期绑定和装载、安全性。

&emsp;&emsp;软件构件是软件系统中具有一定意义的、相对独立的可重用单元。与对象相比，构件可以基于对象实现，也可以不作为对象实现。构件需要在容器中管理并获取容器提供的服务，客户程序可以在运行状态下利用接口动态确定构件所支持的功能并调用。

&emsp;&emsp;构件的3个核心特点：独立部署单元、作为第三方的组装单元、没有外部的可见状态。

&emsp;&emsp;软件构件是部署、版本控制和替换的基本单位。构件是一组通常需要同时部署的原子构件。原子构件通常成组地部署，但是它也能够被单独部署。构件与原子构件的区别在于，大多数原子构件永远都不会被单独部署，尽管它们可以被单独部署。大多数原子构件都属于一个构件家族，一次部署往往涉及整个家族。一个模块是不带单独资源的原子构件。

&emsp;&emsp;面向构件的编程目前缺乏完善的方法学支持，构件交互的复杂性带来了很多问题，其中多线程问题会产生数据竞争和死锁现象。异步问题、多语言支持问题、调用者封装问题。

[![p97u5SU.md.png](https://s1.ax1x.com/2023/05/24/p97u5SU.md.png)](https://imgse.com/i/p97u5SU)

## 9 快速应用开发模型RAD

---

&emsp;&emsp;快速应用开发=瀑布模型(SDLC) + 构建组装模型(CBSD)，可认为它综合了二者的优点；当系统模块化程度较高时可采用该开发模型。

[![p97KtcF.md.png](https://s1.ax1x.com/2023/05/24/p97KtcF.md.png)](https://imgse.com/i/p97KtcF)

## 10 统一过程模型UP/RUP

---

&emsp;&emsp;三大特点：用例驱动、以架构为中心、迭代和增量。

- 四个阶段：采用迭代和增量的方式来开发软件，每完成一次循环则会产生一代软件，这样做的好处是：在软件开发初期就可以对关键的影响大的风险进行处理。
  - 初始：确定项目范围和边界
  - 细化：设计并确定架构体系、指定工作计划及资源要求。
  - 构建：开发剩余的构建、构建组装与测试
  - 交付：制作发布版本

&emsp;&emsp;RUP的9个工作流：商业建模、需求、分析和设计、实现、测试、部署、配置和变更管理、项目管理、环境。注意成本不属于其中。
  
[![p97uTOJ.md.png](https://s1.ax1x.com/2023/05/24/p97uTOJ.md.png)](https://imgse.com/i/p97uTOJ)

>例题
[![pCNJkod.md.png](https://s1.ax1x.com/2023/06/25/pCNJkod.md.png)](https://imgse.com/i/pCNJkod)
{{< expand "学霸肯定对了">}}B A{{< /expand >}}

## 11 敏捷开发模型

---

&emsp;&emsp;小步快跑的模式，适合小型项目。

&emsp;&emsp;敏捷方法是以人为本的适应性方法，它介于无软件开发和传统软件开发方法(注重流程文档)之间；将更重要的注意力集中于可运行的代码本身，而不太重视各类文档、流程之类的。

[![p97MU8f.md.png](https://s1.ax1x.com/2023/05/24/p97MU8f.md.png)](https://imgse.com/i/p97MU8f)

- 价值观与最佳实践

[![p97M5qJ.png](https://s1.ax1x.com/2023/05/24/p97M5qJ.png)](https://imgse.com/i/p97M5qJ)

- 敏捷开发下的模型

[![p97QdF1.md.png](https://s1.ax1x.com/2023/05/24/p97QdF1.md.png)](https://imgse.com/i/p97QdF1)

>例题
[![p97QyOe.md.png](https://s1.ax1x.com/2023/05/24/p97QyOe.md.png)](https://imgse.com/i/p97QyOe)
{{< expand "学霸肯定对了">}}C{{< /expand >}}
[![p97QWFI.md.png](https://s1.ax1x.com/2023/05/24/p97QWFI.md.png)](https://imgse.com/i/p97QWFI)
{{< expand "学霸肯定对了">}}B A{{< /expand >}}
[![p97Q5Sf.md.png](https://s1.ax1x.com/2023/05/24/p97Q5Sf.md.png)](https://imgse.com/i/p97Q5Sf)
{{< expand "学霸肯定对了">}}B{{< /expand >}}
[![p97Qo6S.md.png](https://s1.ax1x.com/2023/05/24/p97Qo6S.md.png)](https://imgse.com/i/p97Qo6S)
{{< expand "学霸肯定对了">}}B D{{< /expand >}}
