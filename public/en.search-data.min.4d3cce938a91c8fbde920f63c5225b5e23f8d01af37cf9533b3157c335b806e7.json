[{"id":0,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/1-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A6%82%E8%BF%B0/","title":"1) 软件架构的概述","section":"3.10 软件架构设计","content":" 1.软件架构的概述🏁 # 1.1 软件架构的概念 # 软件架构即软件体系结构，软件架构设计就是需求的分配，即将满足需求的职责分配到组件上。它搭建起了需求分析与软件设计之间的鸿沟。如下图： 架构的本质\n1. 软件架构为软件系统提供了一个结构、行为和属性的高级抽象。\n2. 软件架构风格是特定应用领域的管用模式，架构定义了一个词汇表和一组约束。 架构的作用\n1. 软件架构是项目干系人进行交流的手段。\n2. 软件架构是可传递和可复用的模型。\n3. 软件架构使推理和控制的更改更加简单，有助于循序渐进的原型设计。 例题 学霸肯定对了 ↕ D 1.2 软件架构的发展 # 软件架构的发展经历了无架构模式(汇编语言)、萌芽阶段(程序结构设计)、初级阶段(统一建模语言UML)、高级阶段(4+1视图)。\n4+1视图如下： 。\n例题 学霸肯定对了 ↕ A D C "},{"id":1,"href":"/docs/example/architect-exam/3.1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","title":"3.1 计算机组成与体系结构","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 ✌ # 计算机结构 ✅ 存储系统 ✅✅✅✅ 数据传输控制方式 ✅ 总线 ✅✅ CISC与RISC ✅ 流水线 ✅✅ 校验码 ✅ 1 计算机结构 # 计算机的硬件包含5大组成：控制器、运算器、存储器、输入设备和输出设备。CPU依据指令周期的不同阶段来区分二进制的指令和数据，因为在指令周期的不同阶段指令会命令CPU分别去取指令或者数据。程序员是可以通过汇编语言直接操作CPU中的寄存器的。\n它们之间的交互如下图（别的部件会在后面的章节详细讲解，这里只说运算器和控制器）： 冯诺依曼结构 一般用于pc处理器，指令和数据存储在一起、指令和数据都是通过相同的数据总线传输，通过不同的周期来区分数据和指令。\n哈佛结构 一般用于嵌入式系统处理器DSP(数字信号处理器)，指令和数据可并行分开存储与传输。\n1.1 运算器 # 算术逻辑单元ALU：实现对数据的算术和逻辑运算。\n累加寄存器AC：通用寄存器、运算结果或源操作数的存放区。\n数据缓冲寄存器DR：暂时存放内存的指令或数据。\n状态条件寄存器PSW：保存指令运行结果的条件码内容，如溢出标志、进位等。\n1.2 控制器 # 程序计数器PC：存储下一条要执行指令的地址。\n指令寄存器IR：存储即将执行的指令。\n指令译码器ID：对指令中的操作码字段进行分析解释。\n时序部件：提供时序控制信号。\n例题 学霸肯定对了 ↕ 答案：A\n计算机执行程序时，在一个指令周期的过程中，为了能够从内存中读指令操作码，首先是将程序计数器(PC)的内容送到地址总线上，PC-\u0026gt;IR。\n学霸肯定对了 ↕ 答案：B 2 存储系统 # 整体采用分层的思想，主要是解决速度、容量和成本之间的矛盾。内存外存称为虚拟存储器、cache内存外存成为三级存储结构.如下图：\n2.1 Cache # 高速缓存Cache用来存储当前最活跃的程序和数据，直接与CPU交互，位于CPU和主存之间,容量小，速度为内存的5-10倍，其内容是主存(内存)的拷贝，对于程序员来说是透明的。Cache由控制部分和存储器组成，存储器存储数据，控制部分判断CPU要访问的数据是否在Cache中，在则命中不在则依据一定的算法从主存中替换。\n地址映射：在CPU工作时，送出的是主存单元的地址，而应从Cache存储器中读/写信息。这就需要将主存地址转换为Cache存储器地址，这种地址的转换称为地址映像，由硬件自动完成映射。\nCache的功能 1.提高CPU数据输入输出的速率，突破冯·诺依曼瓶颈，即突破CPU与存储系统间数据传送带宽限制。\n2.在计算机的存储系统体系中(除cpu中的寄存器外)，Cache是访问速度最快的层次。\n3.Cache对程序员来说是透明的。\n4.使用Cache改善系统性能的依据是程序的局部性原理(总的来说，在CPU运行时，所访问的数据会趋向于一个较小的局部时空内。包括下面两个方面: 时间局部性原理:如果一个数据项正在被访问，那么在近期它很可能会被再次访问(代码里面的循环)，即在相邻的时间里会访问同一个数据项。空间局部性原理:在最近的将来会用到的数据的地址和现在正在访问的数据地址很可能是相近的，即相邻的空间地址会被连续访问(数组))\nCache的命中率 当CPU所访问的数据在Cache中时，命中，直接丛Cache中读取数据，设读取一次Cache时间为1ns，若CPU访问的数据不在Cache中，则需要从内存中读取，设读取一次内存的时间为1000ns，若在CPU多次读取数据过程中，有90%命中Cache(90%一般由cache的算法决定)，则CPU读取一次的平均时间为(90% * 1 + 10% * 1000)ns。\n例题 学霸肯定对了 ↕ 答案：B 学霸肯定对了 ↕ 答案：D 学霸肯定对了 ↕ 答案：A 2.2 主存(内存)编址计算 # 主存如图所示，可以看图试着回答红色框线里面的问题，图中一个存储单元存放了4个bit位，每个存储单元的地址就是我们熟悉的指针，看完应该知道32位机器和64位机器大概是啥意思了。 特别提醒：不要硬算，要化简为二进制或者十进制来算。\n存储单元个数=最大地址-最小地址+1\n编址方式 按字编址：一个存储单元存储的是一个字，最小寻址单位是一个字。 按字节编址：一个存储单元存储的是一个字节，最小寻址单位是一个字节。 总容量=存储单元个数*单个存储单元所占大小\n单位换算：1GB=1024MB，1MB=1024KB，1KB=1024Byte，1Byte=8bit。K=2^10，M=2^20，G=2^30\n例题 学霸肯定对了 ↕ 答案：B C\n总容量=BFFFFH+1-80000H=40000H，转换为十进制为：4 * 16^4=262144，因为按字节编址，所以总容量为262144字节，即262144/1024=256KB，16k * 4bit = 8k * 8bit(1字节=8bit)，所以用这种芯片存这些数据，所需的芯片数量为：256/8=32片\n2.3 磁盘管理 # 磁盘有正反两个盘面，每个盘面有多个同心圆，每个同心圆是一个磁道，每个同心圆又cd被划分为多个扇区，数据就被存放在一个个扇区中。\n磁头首先要寻找到对应的磁道，然后等待磁盘进行周期旋转，旋转到指定的扇区，才能读取到对应的数据，因此，会产生寻道时间和等待时间和存取数据的时间。其公式为：存取时间=寻道时间+等待时间+存取数据时间(在考试时，有这个时间就算上，没有就忽略)\n磁盘调度算法(磁盘旋转是同方向匀速旋转，只会在寻道的时候产生优化算法)\n先来先服务FCFS：根据进程请求访问磁盘的先后顺序进行调度。\n最短寻道时间优先SSTF：请求访问的磁道与当前磁道最进的进程优先调度，使得每次的寻道时间最短。会产生“饥饿”现象，即远处进程可能永远无法访问。\n扫描算法SCAN：又称“电梯算法”，磁头在磁盘上双向移动，其会选择离磁头当前所在磁道最近的请求访问的磁道，并且与磁头移动方向一致，磁头永远都是从里向外或者从外向里一直移动完才掉头。\n单向扫描调度算法CSCAN：与电梯算法类似，与SCAN不同的是，其只做单向移动，即只能从里向外或者从外向里。\n例题 学霸肯定对了 ↕ 答案：D 学霸肯定对了 ↕ 答案：D\n读取一个块需要的时间：10 * 10ms(移动)+100ms(延迟)+2ms(传输)=202ms，读取100个块需要的时间：100ms * 202ms = 20200ms\n学霸肯定对了 ↕ 答案：C B\n由题意可知每个扇区存放逻辑记录，处理单个记录的延时为：33/11+3=6ms，由于磁头处于r0的开始处，且是单缓冲区（同一时间只能一个任务读或者写缓冲区）顺序处理这些记录，所以6+10*(33+3)=366；若对存储信息进行优化，优化后为：r0r6r1r7r2r8r3r9r4r10r5，r0和r5收尾相接形成一个完整的磁道。此时只需要转2圈就可以把数据处理完。\n磁盘单缓冲区与双缓冲区的读取问题 学霸肯定对了 ↕ 答案：D C\n也可用流水线的公式计算，详见流水线例题 3 数据传输控制方式 # 用于主存和外设交换数据。\n3.1 程序查询方式 # CPU主动查询外设是否完成数据传输，如果没有CPU持续查询并等待I/O，效率极低。\n3.2 程序中断方式 # 外设开始或者完成数据传输后，向CPU发送中断，等待CPU处理数据，效率相对较高，中断响应时间指的是从发出中断请求到开始进入中断处理程序;中断处理时间指的是从中断处理开始到中断处理结束。中断向量提供中断服务程序的入口地址。多级中断嵌套，使用栈来保护断点和现场。如鼠标键盘\n3.3 DMA方式 # CPU只需完成必要的初始化等操作，数据传输的整个过程都中，都由DMA控制器来完成，在主存和外设之间建立直接的数据通路，效率很高。如硬盘\n例题 学霸肯定对了 ↕ 答案：D C 学霸肯定对了 ↕ 答案：D 4 总线 # 总线(Bus)，是指计算机设备和设备之间传输信息的公共数据通道，它是一组能为多个部件分时共享的公共信息传输羡慕。总线是连接计算机硬件系统内多种设备的通信线路，它的一个重要特征是由总线上的所有设备共享，因此可以将计算机系统内的多种设备连接到总线上。一条总线同一时刻仅允许一个设备发送，但允许多个设备接收，所以总线是半双工模式(单工：只能单向传输，全双工：可以双向传输)。总线有串行总线和并行总线，串行总线适合长距离传输，并行总线适合于短距离传输。\n总线具体分为数据总线(并行数据传输位数)、地址总线(系统可管理的内存空间的大小) 、控制总线(传送控制命令)。\n例题 学霸肯定对了 ↕ 答案：B 学霸肯定对了 ↕ 答案：C 学霸肯定对了 ↕ 答案：C\n串行总线可以是单工，半双工，全双工，其波特率在使用中是可以改变的，可以是软件查询方式，也可以是中断方式，所以选C\n5 CISC与RISC # 例题 学霸肯定对了 ↕ 答案：B\nx86一般是复杂指令系统，arm系统一般是精简指令集\n6 流水线 # 流水线时间计算 流水线周期：指令分成不同执行段(取址、分析、执行)，其中执行时间最长的段为流水线周期。\n流水线执行时间：1条指令总执行时间(也叫流水线建立时间)+ (总指令条数-1)*流水线周期。\n流水线吞吐率计算：吞叶率即单位时间内执行的指今条数。即：指令条数/流水线执行时间。\n流水线最大吞吐率：周期的倒数。\n流水线的加速比计算:加速比即使用流水线后的效率提升度，即比不使用流水线快了多少倍，越高表明流水线效率越高。即：不使用流水线执行时间/使用流水线执行时间。\n例题 学霸肯定对了 ↕ 答案：D C B C\n解析：设每个盘块儿读入缓冲区的时间为t1、缓冲区送入用户区的时间为t2、用户区处理每个盘块儿的时间为t3，为了能够代入流水线执行时间的公式，需要将题目转成标准的流水线。\n对于单缓冲区而言，需要将3阶段流水线转换成2阶段流水线，即第一阶段为t1+t2，第二阶段为t3，所以：流水线执行时间=1条指令总执行时间+ (总指令条数-1)*流水线周期 = (t1+t2)+t3 + (10-1) * 20 = 201\n对于双缓冲区而言，题目已经是标准流水线了，可以直接带入公式，所以：流水线执行时间=1条指令总执行时间+ (总指令条数-1)*流水线周期 = t1+t2+t3 + (10 - 1) * 15 = 156\n流水线的吞吐率，由题目可知，已是标准流水线，可直接带入公式算吞吐率，设执行了N条指令，n/9t+(n-1) * 3t，即(n/(3n+6)) * (1/t)，当n趋于无穷大时，得到最大吞吐率为1/3t\n流水线的加速比是\u0026gt;=1的，流水线的加速比=不使用流水线执行时间/使用流水线执行时间，不使用流水线执行时间=10 * (2+1+3+1+2)=90，使用流水线执行时间=9+(10-1) * 3=36，即90/36=5/2\n7 校验码 # 校验码是在信息位之外添加额外的bit位，不同的校验方式，加的bit位的位数和位置不同\n7.1 奇偶校验码 # 奇偶校验码:在编码中增加1位校验位来使编码中1的个数为奇数(奇校验)或者偶数(偶校验)，编码中，含有奇数个1，发送给接收方，接收方收到后，会计算收到的编码有多少个1，如果是奇数个，则无误，是偶数个，则有误。\n特点：奇偶校验可检查出1位错位，不可纠错。\n7.2 循环冗余码 # 特点：可检错不可纠错。接收方拿到信息串/生成多项式=0则没错，不为0则传输过程中错误。\n例题 学霸肯定对了 ↕ 答案：A\n解析：补零：原始信息串为1100，生成多项式为3阶，则补3个0，即被除数为：1100000，除数也是根据生成多项式来的，幂指数存在的为1，不存在的为0，即1011(题目已经给出了，未给出的时候要知道是这样算的)，异或相除将余数010(不足3位的在左边补0)添加到原始信息串1100后面得到1100010，即选A\n7.3 海明码 # 特点：可检错，也可纠错\n例题 学霸肯定对了 ↕ 答案：D B\n解析：32 16 8 4 2 1 需要6位。读题目可知D5是第10位，用8+2校验，故选B\n例题 学霸肯定对了 ↕ A 课后习题 # todo 计算机组成与体系结构习题\n"},{"id":2,"href":"/docs/example/","title":"介绍","section":"Docs","content":" 关于博客 # 这个博客是我个人开设的第二个博客，主要用于记录作者在计算机行业摸爬滚打10余年的经历、各类资料干货以及学习心得等，持续更新中\u0026hellip;\u0026hellip;\n本项目的所有的免费资源均挂载在github，地址为：https://github.com/yswang837/yswang837.github.io，同时欢迎热爱开源的朋友fork下来，提交给我你的代码，让我们一起完善这个项目吧；如果你认为本博客帮助了你，欢迎star。\n请你在阅读本站内容时，时刻持有一种质疑的态度，这样不仅能够帮助自己思考，也能发现我文章的不足之处；文章中难免引用到来自网络的各类资料，如果你觉得侵犯了你的版权，请联系我，我将立即删除；如果文章中有什么错漏的地方请大家见谅，也欢迎大家随时加我微信wys837帮我指正，希望与大家一起进步。感谢！\n关于作者 # 笔名：小钻风\n微信：wys837\ngithub: https://github.com/yswang837\n"},{"id":3,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/2-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/","title":"2) 软件架构风格","section":"3.10 软件架构设计","content":" 2.软件架构风格🏁 # 架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个构件有效地组织成一个完整的系统。架构风格定义了用于描述系统的术语表和一组指导构建系统的规则。以下是常见风格的特点或应用：\n批处理\u0026mdash;\u0026gt;传统编译器。\n管道过滤器\u0026mdash;\u0026gt;支持分阶段数据处理。\n层次架构\u0026mdash;\u0026gt;采用层次化架构风格的系统，划分的层次越多，系统性能越差。\n过程控制\u0026mdash;\u0026gt;控制系统，其特点是不断采集系统当前状态，与系统中的设定状态进行对比，并通过将当前状态与设定状态进行对比从而进行控制。\n隐式调用\u0026mdash;\u0026gt;回调机制，采用隐式调用架构风格的系统，可以通过处理函数的并发调用提高系统处理性能。\n事件系统\u0026mdash;\u0026gt;注册事件处理的是回调函数，当某个界面事件发生时（例如键盘敲击、鼠标移动等)，系统会查找并选择合适的回调函数处理该事件。\n解析器\u0026mdash;\u0026gt;运行时的系统行为定义与改变的能力，采用解释器架构风格的系统，可以通过部分解释代码预先编译的方式提高系统性能。\n黑板风格\u0026mdash;\u0026gt;信号处理领域，语音识别系统是一个十分典型的专家系统，其特点是求解的正确结果不止一个，求解过程比较复杂，需要通过专家知识和反馈逐步得到正确结果。\n虚拟机风格\u0026mdash;\u0026gt;通过虚拟机架构屏蔽不同的硬件环境。\nC2体系结构风格\u0026mdash;\u0026gt;通过连接件绑定在一起的按照一组规则运作的并行构件网络。\n数据仓库\u0026mdash;\u0026gt;现代集成开发环境（现代编译器）。\n下图是架构师考试中常见的架构风格及其子风格，接下来会详细介绍每一种风格。 2.1 数据流风格 # 数据流风格以数据驱动的方式推进项目，其的典型应用有传统编译器、网络报文处理，它包含2个子风格：\n1、批处理。做题要点：大量整体数据、无需用户交互\n2、管道过滤器。做题要点：流式数据、弱用户交互\n具体如下图： 2.2 调用/返回风格 # 调用/返回风格包含3个子风格：\n1、主程序/子程序风格\n2、面向对象风格\n3、分层风格，将在“2.8 架构风格具体实例”中详细说明\n2.3 独立构建风格 # 独立构建区别于返回/调用风格的点在于，相对松耦合，且放弃了对子程序的控制，它包含2个子风格：\n1、进程通信\n2、事件驱动系统（隐式调用）\n2.4 虚拟机风格 # 虚拟机风格包含2个子风格：\n1、解释器风格，做题关键字：需要自定义规则的场景\n2、规则系统，做题关键字：在解释器的基础上增加经验规则\n2.5 仓库风格 # 仓库风格包含2个子风格：\n1、数据库系统\n2、黑板系统 2.6 闭环控制风格(过程风格) # 2.7 C2架构风格 # \\\n例题 学霸肯定对了 ↕ 1.虚拟机 2.数据流 3.独立构建风格 4.解释器 5.过程控制 学霸肯定对了 ↕ 1.黑板 2.隐式调用 3.事件驱动风格 学霸肯定对了 ↕ 1.顺序批处理 2.数据共享 3.隐式调用风格 4.模拟 5.虚拟机 2.8 架构风格具体实例 # 没有最好的架构，只有更适合具体业务场景的架构。\n2.8.1 从 C/S -\u0026gt; B/S -\u0026gt; 混合架构 # 双层C/S架构\n通过图示可以看出非常明显的缺点：将业务逻辑的代码嵌入进客户端，在早期互联网并不普及的情况下，频繁变更的业务逻辑代码和难以推广升级的客户端存在巨大矛盾。 三层C/S架构\n相比于双层C/S架构，三层C/S架构的优势在于：将业务逻辑层单独拆分出来(独立于数据库服务器、用户客户端)放在单独的服务器上，经常变更的业务逻辑代码并不会直接影响到客户端的使用。其劣势依然需要用户安装客户端(你可以认为就是手机中的APP)。 B/S架构\n相比于C/S架构，B/S架构也有自己的优缺点\n优势：推广容易，不需要用户下载什么客户端之类的，只需要浏览器访问对应地址即可，这也就是早期各大厂都是从门户网站起家的。\n劣势：响应速度较慢，早期只能整个提交页面数据(不能局部刷新)、其安全性较低等。 混合架构\n结合了C/S和B/S的优势，左图适用于企业内部的软件，对系统的维护有优势；右图适用于主流互联网公司的架构，查询用B/S、修改用C/S架构。 2.8.2 MVC架构风格 # MVC(Model-View-Controller)，Model(模型) 是应用程序中用于处理应用程序数据逻辑的部分，通常模型对象负责在数 据库中存取数据。View(视图) 是应用程序中处理数据显示的部分，通常视图是依据模型数据创建的。Controller(控制器)是应用程序中处理用户交互的部分，通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。\nMVC分为主动MVC和被动MVC(具体不用了解)，MVC架构的缺点在于MV之间没有解耦，不是严格的分层架构(严格的分层架构：当前层之和上下层之间有联系) 在J2EE中（java相关的框架在考试中经常被拿来举例子，因此会java的很有优势），Model是Entity Bean/Session Bean，View是JSP，Controller是Servlet。\n2.8.3 MVP架构风格 # MVP(Model-View-Presenter)，注意：它不是LOL中的MVP，它是MVC的变种，它实现了MV之间的解耦。 2.8.4 MVVM架构风格 # MVVM(Model-ViewModel-View),类似于vue中的双向数据绑定，View改变则ViewModel也改变，反之亦然。 2.8.5 RIA架构风格 # RIA(富互联网架构)类似于综合了C/S和B/S架构的优点(C/S反应快，交互强，B/S易传播)，它在首次加载初期比较慢，一旦加载完成使用就快多了。典型的例子就是在线网游。\n2.8.6 基于服务的架构(SOA) # 1、服务构件粗粒度，传统构件细粒度居多。\n2、服务构件的接口是标准的，主要是WSDL接口，传统构件常以具体API形式出现。\n3、服务构件的实现与语言无关，传统构件绑定某种特定语言。\n4、服务构件可以通过构件容器提供OoS的服务，传统构件完全由程序代码直接控制。 SOA的实现方式：WebService；WSDL就是WebService接口对应的WSDL文件，该文件通过xml格式说明如何调用可以看作WebService的接口文档 (使用说明书)。 SOA的实现方式：ESB 2.8.7 微服务 # 微服务顾名思义，就是很小的服务，所以它属于面向服务架构的一种。 微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通 (通常是基于HTTP协议的RESTfulAPI)。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。\n其特点有：\n1、小,且专注于做一件事情。\n2、轻量级的通信机制。\n3、松耦合、独立部署。\n微服务的优势：\n1、技术异构\n2、弹性扩展\n3、在自动化部署情况下，能简化部署\n4、可组织性\n微服务的挑战：\n1、分布式系统的复杂度\n2、运维成本\n3、服务间的依赖管理和测试\n4、部署自动化\\\nSOA与微服务的对比 2.8.8 MDA # "},{"id":4,"href":"/docs/example/architect-exam/3.2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"3.2 操作系统","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 ✌ # 操作系统概述 操作系统的组成及作用 ✅✅✅ 操作系统的特性 ✅✅✅ 操作系统的分类 ✅✅✅ 进程管理 进程的状态 ✅ 前趋图 ✅✅✅✅ 信号量与P/V操作 ✅✅✅✅ 死锁及银行家算法 ✅ 存储管理 页式存储 ✅✅✅ 段式存储 ✅✅✅ 页面置换算法 ✅ 设备管理 ✅✅ 文件管理 绝对路径与相对路径 ✅ 索引文件 ✅✅✅ 位示图 ✅ 嵌入式操作系统 ✅✅ 实时操作系统 ✅✅ 微内核操作系统 ✅✅ 1. 操作系统概述 # 操作系统是裸机上的第一层软件，它管理着系统的软硬件资源，控制着程序的运行，是应用软件和硬件之间的接口，也是人机交互的接口。它可以管理系统中的进程、存储、文件、作业以及设备。\n例题 学霸肯定对了 ↕ 答案：B 1.1 操作系统的组成及作用 # 操作系统的组成 通常由操作系统内核 (Kernel) 和其他许多附加的配套软件所组成，包括图形用户界面程序、为支持应用软件开发和运行的各种软件构件(如应用框架、编译器和程序库等)、常用的应用程序(如任务管理器、防火墙、网络浏览器等)。\n其中，内核指的是能提供进程管理(任务管理)、存储管理、文件管理和设备管理等功能的那些软件模块，它们是操作系统中最基本的部分，用于为众多应用程序访问计算机硬件提供服务。由于应用程序直接对硬件操作非常复杂，所以操作系统内核对硬件设备进行了抽象，为应用软件提供了一套简洁、统一的接口(称为系统调用接口或应用程序接口 API)。内核通常都驻留在内存中，它以 CPU 的最高优先级运行，能执行指令系统中的特权指令，具有直接访问各种外设和全部主存空间的特权，负责对系统资源进行管理和分配。\n操作系统的作用 操作系统主要有以下 3 个方面的重要作用：\n(1) 管理计算机中运行的程序和分配各种软硬件资源。计算机中一般总有多个程序在运行.这些程序在运行时都可能要求使用系统中的资源(如访问硬盘，在屏幕上显示信息等)，此时操作系统就承担着资源的调度和分配任务，以避免冲突，保证程序正常有序地运行。操作系统的资源管理功能主要包括处理器管理、存储管理、文件管理、I/O 设备管理等几个方面。\n(2) 为用户提供友善的人机界面。人机界面的任务是实现用户与计算机之间的通信(对话)。几乎所有操作系统都向用户提供图形用户界面 (GUI)。\n(3) 为应用程序的开发和运行提供一个高效率的平台。操作系统屏蔽了几乎所有物理设备的技术细节，它以规范、高效的方式 (例如系统调用、库函数等)向应用程序提供了有力的支持，从而为开发和运行其他系统软件及各种应用软件提供了一个平台。\n1.2 操作系统的特性 # 并发性 在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序同时运行，但实际上在单CPU的运行环境，每一个时刻只有一个程序在执行。因此，从微观上来说，各个程序是交替、轮流执行的，如果计算机系统中有多个 CPU，则可将多个程序分配到不同 CPU 上实现并行运行。\n共享性 共享是指操作系统中的资源(包括硬件资源和信息资源)可以被多个并发执行的进程(线程)共同使用，而不是被一个进程所独占。\n不确定性 但由于资源有限，在多数情况下进程的执行不是一贯到底的，而是“走走停停”。例如一个进程，在 CPU上运行一段时间后，由于等待资源或某事件发生，它被暂停执行，将 CPU 转让给另一个进程执行。系统中的进程何时执行，何时暂停，以什么样的速度向前推进，进程总共要花多少时间执行才能完成，这些都是不可预知的。\n1.3 操作系统的分类 # 批处理操作系统\n单道批处理系统 单道批处理操作系统是一种早期的操作系统，用户可以向系统提交多个作业，“单道”的含义是指一次只有一个作业装入内存执行。作业由用户程序、数据和作业说明书(作业控制语言)3个部分组成。当一个作业运行结束后，随即自动调入同批的下一个作业，从而节省了作业之间的人工干预时间，提高了资源的利用率。\n多道批处理操作系统 允许多个作业装入内存执行，在任意一个时刻，作业都处于开始点和终止点之间。每当运行中的一个作业由于输入/输出操作需要调用外部设备时，就把 CPU 交给另一个等待运行的作业，从而将主机与外部设备的工作由串行改变为并行，进一步避免了因主机等待外设完成任务而浪费宝贵的 CPU 时间。多道批处理系统主要有3 个特点:多道、宏观上并行运行和微观上串行运行。\n分时操作系统 在分时操作系统中，一个计算机系统与多个终端设备连接。分时操作系统是将 CPU 的工作时间划分为许多很短的时间片，轮流为各个终端的用户服务。例如，一个带 20 个终端的分时系统，若每个用户每次分配一个 50ms 的时间片，则每隔 1s 即可为所有的用户服务一遍。因此,尽管各个终端上的作业是断续运行的，但由于操作系统每次对用户程序都能做出及时响应，因此用户感觉整个系统均归其一人占用。\n实时操作系统 实时是指计算机对于外来信息能够以足够快的速度进行处理，并在被控对象允许的时间范围内做出快速反应。实时系统对交互能力要求不高，但要求可靠性有保障。\n实时系统分为实时控制系统和实时信息处理系统。实时控制系统主要用于生产过程的自动控制，例如数据自动采集、武器控制、火炮自动控制、飞机自动驾驶和导弹的制导系统等。实时信息处理系统主要用于实时信息处理，例如飞机订票系统、情报检索系统等。\n网络操作系统 网络操作系统是使联网计算机能方便而有效地共享网络资源，为网络用户提供各种服务的软件和有关协议的集合。\n分布式操作系统 分布式计算机系统是由多个分散的计算机经连接而成的计算机系统，系统中的计算机无主次之分，任意两台计算机可以通过通信交换信息。通常，为分布式计算机系统配置的操作系统称为分布式操作系统。分布式操作系统能直接对系统中的各类资源进行动态分配和调度、任务划分、信息传输协调工作，并为用户提供一个统一的界面与标准的接口，用户通过这一界面实现所需要的操作和使用系统资源，使系统中若干台计算机相互协作完成共同的任务，有效地控制和协调诸任务的并行执行。分布式操作系统是网络操作系统的更高级形式，它保持网络系统所拥有的全部功能，同时又有透明性、可靠性和高性能等特性。\n微型计算机操作系统 微型计算机操作系统简称微机操作系统，常用的有 Windows、Mac OS、Linux。\n嵌入式操作系统 嵌入式操作系统运行在嵌入式智能设备环境中微型化，其主要特点如下：微型化、可定制、实时性、可靠性、易移植性\n2 进程管理 # 进程由进程控制块PCB(唯一标识)+程序(描述进程要做什么)+数据(存放进程执行所需的数据)。程序是放在外存中的文件(静态的)，进程是程序的一次执行过程(动态的)。下图是进程和线程的关系，明显看出来选C\n2.1 进程的三态图 # 三态图之间的状态转换就是PV操作来控制的。系统中资源一般分为：\n1、CPU资源： 有 无 无\n2、非CPU资源： 有 有 无\n例题 学霸肯定对了 ↕ A C\n解析：参考进程三态图\n学霸肯定对了 ↕ C C 2.2 进程间的同步互斥 # 临界资源：各进程间需要以互斥方式对其进行访问的资源。\n临界区：指进程中对临界资源实施操作的那段程序。本质是一段程序代码。\n互斥模型：某资源 (即临界资源)在同一时间内只能由一个进程单独使用，使用时需要加锁，使用完后解锁才能被其他任务使用，属于间接制约关系;如打印机、缓冲区。\n同步模型：多个任务可以并发执行(进程与进程之间存在协作关系)，只不过有速度上的差异，在一定情况下停下等待，属于直接制约关系，不存在资源是否单独或共享的问题;如自行车和汽车。\n互斥模型的信号量：对临界资源采用互斥访问，使用互斥信号量后其他进程无法访问，它是全局变量，一般用S表示，的初值为1。\n同步模型的信号量：同步信号量:对共享资源的访问控制，初值一般是共享资源的数量，它是全局变量；一般用S表示，如公司电脑数量。\n2.3 前趋图与PV操作 # P操作：申请并占用资源，S=S-1，若S\u0026gt;=0，则执行P操作的进程继续执行;若S\u0026lt;0，则置该进程为阻塞状态 (因为无可用资源)，并将其插入阻塞队列。可认为是加锁操作。\nV操作：释放资源，S=S+1，若S\u0026gt;0，则执行V操作的进程继续执行:若S\u0026lt;=0，则从阻塞状态唤醒一个进程，并将其插入就绪队列(此时因为缺少资源被P操作阻塞的进程可以继续执行)，然后执行V操作的进程继续。可认为解锁操作。\nPV操作与互斥模型示例 PV操作与同步模型示例 下图中的进程队列是阻塞进程队列，当S为-3时，可认为是有3个进程在等待资源。\nPV操作在前趋图中的应用 前趋图是一个有向无环图，箭头的结束位置为P操作，箭头的开始位置为V操作\ngithub摘抄\n进程通常分为就绪、运行和阻塞三个工作状态。三个状态之间的转换就是靠PV操作来控制的。 PV操作主要就是P操作、V操作。信号量的值只能由PV操作来改变。 信号量是最早出现的用来解决进程同步与互斥问题的机制。 P表示获得，V表示释放。来源于荷兰语，P和V是荷兰语两个单词的首字母。\n信号量（Semaphore）由一个值和一个指针组成，指针指向等待该信号量的进程。信号量的值表示相应资源的使用情况。\n信号量S\u0026gt;=0时，S表示可用资源的数量。 当S\u0026lt;0时，表示已经没有可用资源，S的绝对值表示当前等待该资源的进程数。请求者必须等待其他进程释放该类资源，才能继续运行。 执行一次P操作意味着请求分配一个资源，因此S的值减1； 执行一个V操作意味着释放一个资源，因此S的值加1；此时若S\u0026lt;0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。\nS大于0那就表示有临界资源可供使用，为什么不唤醒进程？ S大于0的确表示有临界资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒。\nS小于0应该是说没有临界资源可供使用，为什么还要唤醒进程？ V原语操作的本质在于：一个进程使用完临界资源后，释放临界资源，使S加1，以通知其它的进程，这个时候如果S\u0026lt;0，表明有进程阻塞在该类资源上，因此要从阻塞队列里唤醒一个进程来“转手”该类资源。比如，有两个某类资源，四个进程A、B、C、D要用该类资源，最开始S=2，当A进入，S=1，当B进入S=0，表明该类资源刚好用完， 当C进入时S=-1，表明有一个进程被阻塞了，D进入，S=-2。当A用完该类资源时，进行V操作，S=-1，释放该类资源，因为S\u0026lt;0，表明有进程阻塞在该类资源上，于是唤醒一个。\n如果是互斥信号量的话，应该设置信号量S=1，但是当有5个进程都访问的话，最后在该信号量的链表里会有4个在等待，也是说S=-4，那么第一个进程执行了V操作使S加1，释放了资源，下一个应该能够执行，但唤醒的这个进程在执行P操作时因S\u0026lt;0，也还是执行不了，这是怎么回事呢？ 当一个进程阻塞了的时候，它已经执行过了P操作，并卡在临界区那个地方。当唤醒它时就立即进入它自己的临界区，并不需要执行P操作了，当执行完了临界区的程序后，就执行V操作。\nS的绝对值表示等待的进程数，同时又表示临界资源，这到底是怎么回事？ 当信号量S小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目.S大于0时表示可用的临界资源数。注意在不同情况下所表达的含义不一样。当等于0时，表示刚好用完。\n例题 学霸肯定对了 ↕ 答案：B A\n解析：考察同步互斥，互斥信号量的初始值为1，同步信号量的初始值为\n学霸肯定对了 ↕ 答案：C A 2.4 死锁 # 死锁就考死锁资源的计算。\n例题 学霸肯定对了 ↕ 答案：B\n解析：当前可用资源R1为9-7=2，R2为8-7=1，R3为5-5=0，进程P1的仍需R1资源数为6-1=5，以此类推算出所有进程的所有仍需资源数，发现首先执行P2，P2执行完成后，会释放P2的资源，即当前的发现可用资源210+211=4，2，1，即可算出是答案B\n3 存储管理 # 外存往内存调用数据\n3.1 分页存储管理 # 分页存储管理管理的是内存和外存之间的数据(同cache和内存之间的管理一样，只不过cache和内存之间靠的是硬件，而内存与外存靠的是软件（页表），这里是页式存储管理)。 页式存储管理：将用户程序(外存)与内存均划分为相同大小的块，以页为单位将程序调入内存；这样会产生一个页表的数据结构，用户程序称为逻辑页，对应于页表的页号，内存划分对应于物理块号；\n逻辑地址：页号+页内地址\n物理地址：块号(页帧号)+页内地址\n逻辑页分为页号和页内地址，页内地址就是物理偏移地址，而页号与物理块号并非按序对应的，需要查询页表，才能得知页号对应的物理块号，再用物理块号加上偏移地址才得出了真正运行时的物理地址。如果CPU查找数据时，内存中没有，就会产生缺页中断，重新去外存寻找数据。当要调用逻辑页号为3的页面到内存时，优先淘汰访问位0的页面，当多个页面的访问位为0时，才会优先淘汰修改位为0的页面。\n页面置换算法 最优算法:0PT，理论上的算法，无法实现，是在进程执行完后进行的最佳效率计算，用来让其他算法比较差距。原理是选择未来最长时间内不被访问的页面置换，这样可以保证未来执行的都是马上要访问的。\n先进先出算法:FIFO，先调入内存的页先被置换淘汰，会产生抖动现象，即分配的页帧数越多缺页率可能越多(即效率越低)。\n最近最少使用:LRU，在最近的过去，进程执行过程中，过去最少使用的页面被置换淘汰，根据局部性原理，这种方式效率高，且不会产生抖动现象，使用大量计数器，但是没有LFU多。\n淘汰原则:优先淘汰最近未访问的，而后淘汰最近未被修改的页面。\n快表:是一块小容量的相联存储器，由快速存储器组成，按内容访问，速度快，并且可以从硬件上保证按内容并行查找，一般用来存放当前访问最频繁的少数活动页面的页号。快表是将页表存于Cache中;慢表是将页表存于内存上。慢表需要访问两次内存才能取出页，而快表是访问一次Cache和一次内存，因此更快。\n例题 学霸肯定对了 ↕ 答案：C D\n页面大小为512字节，则需要用9个bit位表示；十进制的1111的二进制表示为：100 0101 0111，所以页号为二进制10，则十进制的2，查页表得知物理页4，所以选C，读题可知直接选D，因为都要共享8\n学霸肯定对了 ↕ 答案：A B\n页面大小为4k，得用12个bit位表示；逻辑地址=页号+页内地址，5148H的二进制的低12位都用于表示页内地址，高4位用于表示页号，所以页号就是5(0101)；物理地址=物理块号+页内地址，查页表得知块号=3，所以其物理地址的十六进制为A选项；淘汰的是在内存中，首先访问位为0的页面，即2，若多个访问位为0，则淘汰修改位为0的页面，所以选B\n学霸肯定对了 ↕ 答案：A C\n由程序得知矩阵是按行访问，若按行存放，则缺页中断次数=10000/200=50次，若按列存放，则缺页中断次数=10000/2=5000次\n3.2 分段存储管理 # 按逻辑上的大小来截断(和页式存储不同，页式存储固定大小页面)，将进程空间分为一个个段，每段也有段号和段内地址，与页式存储不同的是，每段物理大小不同，分段是根据逻辑整体分段的，因此，段表也与页表的内容不同，页表中直接是逻辑页号对应物理块号，而下图所示，段表有段长和基址两个属性，才能确定一个逻辑段在物理段中的位置。\n学霸肯定对了 ↕ D C 4 设备管理 # 4.1 I/O软件层次 # I/O设备管理软件的所有层次及每一层功能如下图：\n实例：当用户程序试图读一个硬盘文件时，需要通过操作系统实现这一操作。与设备无关软件检查高速缓存中有无要读的数据块，若没有，则调用设备驱动程序，向1/0 硬件发出一个请求。然后，用户进程阻塞并等待磁盘操作的完成。当磁盘操作完成时，硬件产生一个中断，转入中断处理程序。中断处理程序检查中断的原因，认识到这时磁盘读取操作已经完成，于是唤醒用户进程取回从磁盘读取的信息，从而结束此次1/0 请求。用户进程在得到了所需的硬盘文件内容之，后继续运行。\n4.2 SPOOLING技术 # 虚拟性是OS的四大特性之一。如果说可以通过多道程序技术将一台物理CPU虚拟为多台逻辑CPU，从而允许多个用户共享一台主机，那么，通过SPOOling技术便可将一台物理I/O设备虚拟为多台逻辑I/O设备，同样允许多个用户共享一台物理I/O设备。\n5 文件管理 # 5.1 索引文件结构 # 如图所示，一般linux的系统中默认有13个索引节点，索引可以理解为地址、指针、盘块号，0-9为直接索引,即每个索引节点存放的是内容，假设每个物理盘大小为4KB，共可存4KB*10=40KB数据。\n10号索引节点为一级间接索引节点，大小为4KB，存放的并非直接数据，而是链接到直接物理盘块的地址，假设每个地址(指针、盘块号)占4B，则共有4KB/4B = 1024个地址，对应1024个物理盘，可存1024*4KB=4096KB数据。\n11号索引节点为二级索引节点，直接盘存放一级地址，一级地址再存放物理盘快地址，而后链接到存放数据的物理盘块，容量又扩大了一个数量级，为1024 * 1024 * 4KB数据。\n学霸肯定对了 ↕ 答案：C D\n地址大小为4Byte，磁盘索引块和磁盘数据块都是4KB大小，所以单个索引块存储了4KB/4B=256个地址，物理块一般来说在内存中是离散的，而逻辑块是连续的，所以物理块号50对应于0，67-\u0026gt;1，68-\u0026gt;2\u0026hellip;89-\u0026gt;4，58-\u0026gt;5，136的逻辑号为x-5+1=256,得到x=260，即136-\u0026gt;260，187-\u0026gt;261，所以答案选C，看题知道第二空选D\n5.2 文件目录 # 相对路径：是从当前路径开始的路径。\n绝对路径：是从根目录开始的路径。\n全文件名=绝对路径+文件名。要注意，绝对路径和相对路径是不加最后的文件名的，只是单纯的路径序列。\n5.3 位示图 # 位示图是用于记录文件存储器的使用情况。每一位对应文件存储器上的一个物理块，取值 0 和 1 分别表示空闲和占用。\n学霸肯定对了 ↕ 答案：C D\n物理块号编址从0开始，所以总物理块数为16385+1=16386，16386/32=512余2，位示图编号从0开始，所以前511号编满了，512号编到第二个位置，选C，1000G*1024/4/32=8000，选D\n6. 嵌入式操作系统 # 嵌入式系统的初始化过程：片级初始化-\u0026gt;版级初始化-\u0026gt;系统初始化\n嵌入式系统主要由嵌入式硬件平台、相关支撑硬件、嵌入式操作系统、支撑软件和应用软件组成。其中，嵌入性、专用性和计算机系统是嵌入式系统的三个核心要素。典型的嵌入式系统具有以下特点:系统专用性强、系统实时性强、软硬件依赖性强、处理器专用、多种技术紧密结合、系统透明性、系统资源受限。\n嵌入式操作系统特点:(1) 微型化、(2) 代码质量高、(3) 专业化、(4) 实时性强、(5) 可裁减、可配置。针对不同的硬件平台，操作系统通常建立在一个硬件抽象层 (HAL)上，该层位于底层硬件和内核之间，为内核提供各种方便移植的宏定义接口，在不同的平台间移植时，只需要修改宏定义即可。与硬件相关，与操作系统相关。\n低功耗 嵌基于硬件的低功耗设计：板级电路低功耗设计，选择低功耗处理器，总线的低功耗设计;接口驱动电路的设计，分区分时供电技术。\n嵌基于软件的低功耗设计：编译优化技术 (指令开销)，软件与硬件的协同设计 (硬件功能交由软件完成)，算法优化 (低时间复杂度)。\n例题 学霸肯定对了 ↕ C 学霸肯定对了 ↕ D 学霸肯定对了 ↕ B 7. 实时操作系统 # 性能指标 任务切换时间\n断处理相关的时间指标：中断延迟时间、中断响应时间\n系统响应时间 (对用户的输入或请求作出反应的时间)\n信号量混洗时间 (指从一个任务释放信号量到另一个等待该信号量的任务被激活的时间延迟)\n实时操作系统任务调度算法 实时系统存在多种调度算法，在RTOS中，大多数的RTOS调度算法都是抢占式的。\n优先级调度算法: 分配一个相对固定的优先顺序，然后调度程序根据优先级的高低排序，按时间顺序进行高优先级任务优先调度。(非抢占式)\n抢占式优先级调度算法:是在优先级调度算法基础上，允许高优先级任务抢占低优先级任务而运行。\n时间轮转调度算法:调度程序会依次调度每个任务运行一个小的时间片，然后再调度另一个任务。每个任务运行完一个时间片，无论是否结束都会释放CPU让下一个任务运行。(纯粹的时间轮转调度无法满足实时系统的要求，取而代之的是基于优先级的抢占式时间。\n轮转调度)最晚截止期调度算法:指调度程序按每个任务的最接近其截止期末端的时间进行调度。最早截止期调度算法，指调度程序按每个任务的截止期时间，选择最早到截止期头端时间的任务进行调度。\n例题 学霸肯定对了 ↕ A 学霸肯定对了 ↕ B 8. 微内核操作系统 # 现代操作系统大多拥有两种工作状态，分别是核心态和用户态。一般应用程序工作在用户态，而内核模块和最基本的操作系统核心工作在核心态。\n将传统的操作系统代码放置到更高层，从操作系统中去掉尽可能多的东西，而只留下最小的核心，称之为微内核。(C/S结构)\n例题 学霸肯定对了 ↕ A 课后习题 # todo 操作系统习题\n"},{"id":5,"href":"/docs/example/architect-exam/3.3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/","title":"3.3 数据库系统","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 ✌ # 数据库模式✅ 分布式数据库✅✅✅ 分布式数据库的特点 分布式数据库的层次 分布透明性 分布式数据库的两阶段提交协议 数据库设计阶段✅✅ 需求分析✅ 概念结构设计\u0026ndash;ER模型✅ 逻辑结构设计\u0026ndash;关系模型✅✅ 物理设计✅ 关系代数✅✅✅✅ 规范化理论✅✅✅✅✅ 函数依赖 求候选键 Armstrong公理 范式判断 模式分解 并发控制✅ 数据库的安全性✅ 数据库的备份与恢复技术✅ 数据库性能优化✅ 专项练习 1 数据库模式 # 数据库模式一句话概括为三级模式两级映像，其中三级模式分别是：外模式(用户模式、子模式)、模式(概念模式)、内模式；两级映像分别是：外模式与模式之间的映像、模式与内模式之间的映像。\n外模式 它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的逻辑表示。它是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。外模式反映了数据库的用户观。\n模式 又称概念模式或逻辑模式，它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图（全局视图）。体现和反映了数据库系统(DBS)的整体观。\n内模式： 又称存储模式，对应于物理级。它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。它是数据库的存储观。\n外模式-模式（逻辑数据独立性） 用户应用程序根据外模式进行数据操作，通过外模式—模式映射，定义和建立某个外模式与模式间的对应关系，将外模式与模式联系起来，当模式发生改变时，只要改变其映射，就可以使外模式保持不变，对应的应用程序也可保持不变。\n模式-内模式（物理数据独立性） 通过模式—内模式映射，定义建立数据的逻辑结构（模式）与存储结构（内模式）间的对应关系，当数据存储结构发生变化时，只需改变模式—内模式映射，就能保持模式不变，因此应用程序也可以保持不变。\n关系的3种类型 基本关系 (通常又称为基本表或基表) : 实际存在的表，实际存储数据的逻辑表示。\n查询表:查询结果对应的表。\n视图表:由基表或其他视图表导出的表，本身不独立存储，数据库只存放它的定义，常称为虚表。\n视图表 数据库视图:它一个虚拟表 (逻辑上的表)，其内容由查询定义(仅保存SOL查询语句)同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并没有真正存储这些数据，而是通过查询原始表动态生成所需要的数据。\n视图的优点:\n1、视图能简化用户操作\n2、视图使用户能以多种角度看待同一数据\n3、视图对重构数据库提供了一定程度的逻辑独立性\n4、视图可以对机密数据提供安全保护\n物化视图:它不是传统意义上虚拟视图，是实体化视图，其本身会存储数据。同时当原始表中的数据更新时，物化视图也会更新。适合于多查询少更新的场景。\n2 分布式数据库 # 分布式数据对应于集中式数据库而言的，平时所用到的SQL Server等都是集中式数据库，分布式会考虑物理上把数据放在不同的物理节点上。\n2.1 分布式数据库的特点 # 数据独立性 除了数据的逻辑独立性与物理独立性外，还有数据分布独立性 (分布透明性)。\n集中与自治共享结合的控制结构 各局部的DBMS可以独立地管理局部数据库，具有自治的功能。同时，系统又设有集中控制机制，协调各局部DBMS的工作，执行全局应用。\n适当增加数据冗余度 在不同的场地存储同一数据的多个副本可以提高系统的可靠性和可用性，同时也能提高系统性能。提高系统的可用性，即当系统中某个节点发生故障时，因为数据有其他副本在非故障场地上，对其他所有场地来说，数据仍然是可用的，从而保证数据的完备性。\n全局的一致性、可串行性和可恢复性 该点和集中式数据库的特点一致。\n2.2 分布式数据库的层次 # 分布式数据库的层次和数据库的三级模式两级映像大致相似，只不过在原有的“外模式”、“概念模式”、“内模式”上增加了一些具体的特性，如分片模式有(垂直分片、水平分片、混合分片)，分布模式(表示具体放在哪个物理节点)，分布式数据库的全局外模式和集中式数据库的外模式一样，都直接用于用户程序，分布式数据库的局部概念模式和集中式数据库的概念模式一样，都是库表，局部内模式同集中式数据库的内模式一样，其具体情况如下图：\n分布式数据库管理系统(DDBMS, Distributed Database Management System)由局部数据库管理系统(LDBMS, Local Database Management System)、全局数据库管理系统(GDBMS, Global Database Management System)、数据字典和通信管理(CM, Communication Management)组成。\n分布式数据库管理系统的结构有：(1)全局控制集中的DDBMS (2)全局控制分散的DDBMS (3)全局控制部分分散的DDBMS。\n2.3 分布透明性 # 分布透明性分为：分片透明性、复制透明性、位置透明性、局部数据模型透明性；其中分片透明性又分为：水平分片、垂直分片、混合分片。\n分片透明： 是指用户不必关心数据是如何分片的，它们对数据的操作在全局关系上进行，即如何分片对用户是透明的。\n复制透明： 用户不用关心数据库在网络中各个节点的复制情况，被复制的数据的更新都由系统自动完成。\n位置透明： 是指用户不必知道所操作的数据放在何处，即数据分配到哪个或哪些站点存储对用户是透明的。\n局部映像透明性(逻辑透明)： 是最低层次的透明性，该透明性提供数据到局部数据库的映像，即用户不必关心局部DBMS支持哪种数据模型使用哪种数据操纵语言，数据模型和操纵语言的转换是由系统完成的。因此，局部映像透明性对异构型和同构异质的分布式数据库系统是非常重要的。\n2.4 分布式数据库的两阶段提交协议 # 1、表决阶段：目的是形成一个共同的决定。\n2、执行阶段：目的是实现这个协调者的决定。\n两条全局提交规则 1、只要有一个参与者撤销事务，协调者就必须做出全局撤销决定。\n2、只有所有参与者都同意提交事务，协调者才能做出全局提交决定。\n例题\u0026gt; 学霸肯定对了 ↕ D 学霸肯定对了 ↕ D 学霸肯定对了 ↕ C 3 数据库设计阶段 # 数据库设计包含需求分析-\u0026gt;概念结构设计-\u0026gt;逻辑结构设计-\u0026gt;物理设计阶段，每阶段的产物需要知道。\n例题 学霸肯定对了 ↕ C\n需求分析产物有：数据流图、数据字典、需求说明书，概念结构设计的产物有：ER图，逻辑结构设计的产物有：关系模式，还需要考虑ER图转关系模式的转换规则和规范化相关的一些东西，物理设计考虑的是具体的物理存储、物理分布等，故选C\n学霸肯定对了 ↕ C 3.1 需求分析 # 根据当前和未来应用的数据要求、数据处理要求来进行需求分析，此阶段的产物有：数据流图、数据字典、需求说明书。\n3.2 概念结构设计 # 概念结构设计也就是通过需求分析的结果来获得ER图的过程。下图是示例的ER图：\nER图就是实体联系图，两个不同的实体集之间有三种联系，分别是1:1,1:m,m:n。上图是m:n的多对多关系(联系的类型需要会判断)。\nE-R图具体的建立过程 合并的方法：多个局部E-R图一次集成。逐步集成，用累加的方式一次集成两个局部E-R。\n合并产生的冲突及解决办法：属性冲突:包括属性域冲突和属性取值冲突；命名冲突:包括同名异义和异名同义；结构冲突:包括同一对象在不同应用中具有不同的抽象，以及同一实体在不同局部E-R图中所包含的属性个数和属性排列次序不完全相同。\n3.3 逻辑结构设计 # 逻辑结构设计的产物是关系模式，ER图+转换规则和规范化理论=关系模式(关系模型)。数据模型三要素：数据结构、数据操作、数据的约束条件。数据模型包括层次模型、网状模型、面向对象模型、关系模型。\n以下的几种形式都是关系模型。\n关系模型的相关概念 以学生、选课关系为例，说明关系模型中的相关概念。其中：学生(学号，姓名，年龄，班级编号)和选课(学号，课程号，课程名)。\n1、学生关系是一个4目关系；选课关系是一个3目关系。\n2、学生关系的候选码只有一个，是学号；选课关系的候选码也只有一个，是(学号，课程号)。\n3、学生关系的主键是学号；选课关系的主键是(学号，课程号)。\n4、学生关系的主属性有学号，非主属性有姓名，年龄，班级编号；选课关系的主属性有学号和课程号，非主属性有课程名。\n5、学生关系没有外键；选课关系的外键是学号，学号是学生关系的主键。\n6、学生关系没有全码，选课关系也没有全码。全码(全部属性都是候选码，即选课关系去掉课程名之后，剩下的就是全码)\n完整性约束\n实体完整性：规定基本关系的主属性不能取空值。跟主键相关\n参照完整性：关系与关系之间的引用。跟外键相关\n用户自定义完整性：应用环境决定。如年龄取值范围等。\n触发器：复杂的完整性约束，可做逻辑判断等功能。\n例题 学霸肯定对了 ↕ B 关系模式的具体的建立过程 1、ER图向关系模式转换：实体向关系模式转换；联系向关系模式转换。\n2、关系模式的规范化。\n3、确定完整性约束(保证数据的正确性)。\n4、用户视图的确定(提高数据的安全性和独立性)：根据数据流图确定处理过程使用的视图；根据用户类别确定不用用户使用的使用。\n5、应用程序设计。\nER图向关系模式转换 其余的放在后续章节介绍。\n例题 学霸肯定对了 ↕ C 学霸肯定对了 ↕ D C A 3.4 物理设计 # 物理设计考虑具体的物理存储、物理分布情况。\n4 关系代数 # 关系代数是针对关系模式进行的代数运算。\n并交差是同构的二元运算。\n笛卡尔积、投影选择可是同构，也可异构；笛卡尔积是二元运算，投影、选择都是一元运算；它们都可用1，2，3\u0026hellip;来代替列名，有同名的情况需要加上“表名.”。经常会出现这样的sql考察形式：select 投影 from 笛卡尔积 where 选择。\n连接有多种，考试基本上只考自然连接。有同名的情况需要加上“表名.”。笛卡尔积的结果非常庞大，将笛卡尔积进行适当的选择、投影(注意顺序，下面两个式子中，第一个是对的)就可以得到自然连接的结果，所以也会考察它们相等的情况。如果考虑性能情况，一般需要先投影选择之后再做笛卡尔积或自然连接的性能最高。\n例题 学霸肯定对了 ↕ D C 学霸肯定对了 ↕ B C 5 规范化理论 # 规范的必要性 非规范化的关系模式可能存在的问题包括：数据冗余、更新异常(修改操作一致性问题)、插入异常、删除异常。\n经常考察的点：\n1、给你一个关系模式，让你看看有啥问题，做法：先看该关系模式达到第几范式，再说出对应范式的问题就行；\n2、让你修改关系模式来消除这些问题。一般来说没达到第三范式都有问题。\n5.1 函数依赖 # 函数依赖是一个语义概念，是一个自然而然的概念。如果x能唯一决定y，则称x函数决定y，或者是y函数依赖于x，记作x-\u0026gt;y。\n特殊的函数依赖关系\n部分函数依赖 传递函数依赖 5.2 求候选键 # 候选键可以有多个，每个候选键可以由多个属性构成。知道候选键了以后，其余的情况都知道了，现在介绍如何求取候选键。\n1、在关系模式中，一般用R(U,F)表示，U是属性，表示节点；F是函数依赖，表示边；所以将关系模式转换为一个有向图（可选）。\n2、(入度出度都为0的属性一定是在候选码中)，找入度为0的属性(只在箭头左边出现过的属性就是入度为0的属性；箭头指入为入度，箭头指出为出度)，并以该属性集合为起点，尝试遍历有向图，若能正常遍历图中所有结点，则该属性集即为关系模式的候选键。\n3、若入度为0的属性集不能遍历图中所有结点，则需要尝试性的将一些中间结点(既有入度，也有出度的结点)并入入度为0的属性集中，直至该集合能遍历所有结点，集合为候选键。\n例题 学霸肯定对了 ↕ A ABCD B 5.3 Armstrong公理 # 函数依赖在题目中一般都给的不全，但是我们可以通过题目给的函数依赖推导出所有的属性，期间推导的依据就是Armstrong公理。\n例题 学霸肯定对了 ↕ C 5.4 范式判断 # 关系数据库在设计过程中必然会考虑到规范化程度，范式就是判断规范化程度的度量。欲达到更高的规范化程度，则需要将表格拆分得更细。拆分得越细，查询性能会越低，所以并不是越细越好，所以也会出现非规范化理论。一般在开发过程中达到第三范式就刚好。\n第一范式 最普通的二维表就达到了第一范式，一般题目给到的表，都是达到了第一范式。所以下表不满足第一范式，不是普通二维表，因为高级职称人数可继续拆分。\n第二范式 该例子是一个普通的二维表，所以该关系模式至少达到了第一范式，但该关系模式存在非主属性对候选码的部分函数依赖(学分部分依赖候选码学号和课程号)，所以改关系模型未能达到第二范式，目前只是第一范式。存在部分函数依赖的前提是候选码至少由两个及以上的属性构成。若消除了非主属性对候选码的部分函数依赖，则该关系模式可以达到第二范式；如何消除？将该关系模式(学号，课程号，成绩，学分)拆成两个关系模式(课程号，学分)和(学号，课程号，成绩)。\n第三范式 该例子是普通二维表且候选码只有一个属性构成，所以该关系模式至少达到了第二范式。主属性学号-\u0026gt;系号，系号-\u0026gt;系名和系位置(其中系号一定是非主属性才行)；所以该关系模式存在非主属性对主属性的传递依赖(系名和系位置传递依赖于学号)，所以该关系模式未达到第三范式。若消除了非主属性对主属性的传递依赖，则该模式可以达到第三范式，如何消除？将关系模式(学号，姓名，系号，系名，系位置)拆分成两个关系模式(学号，姓名，系号)和(系号，系名，系位置)。\nBCNF范式 该例子是是普通二维表且没有非主属性(F{T-\u0026gt;J,SJ-\u0026gt;T}，所以候选码为：SJ，ST)，所以该关系模型至少达到了第三范式。当且仅当F中的每个依赖的左边都必定包含R的某个候选码时，就达到BCNF范式。显然T不包含SJ或ST，所以未达到BCNF范式。\n例题 学霸肯定对了 ↕ C A 5.5 模式分解 # 将关系模式拆分成更小的关系模式以达到更高的规范化程度的过程就是模式分解的过程。模式分解的过程中，需要考虑两个问题：1、是否保持函数依赖；2、是否无损分解。比较好的模式分解应该是即保持了函数依赖，又是无损分解。\n保持函数依赖分解 关系模式分解前必然存在一个函数依赖集合F，关系模式分解后假设得到了两个关系模式，那么这两个关系模式也必定有自己的函数依赖集合F1，F2；若F1并F2等价于F，则称这种模式分解保持了函数依赖。在F中可能存在冗余函数依赖，它其实是可以通过公理推导出来的，所以在判断是否保持函数依赖时不用考虑冗余函数依赖。\n例题 学霸肯定对了 ↕ 是 是\n第一问解析：R1的函数依赖F1={A-\u0026gt;B}，R2的函数依赖F2={B-\u0026gt;C}，函数依赖F1并F2是等价于分解前的函数依赖F的，所以该分解保持了函数依赖。第二问解析：同第一问一样，只不过F中存在了冗余函数依赖A-\u0026gt;C(通过传递律可知)，在判断的时候不需要考虑，所以该分解保持了函数依赖。\n学霸肯定对了 ↕ 不是 是\n第一问解析：R1的函数依赖F1={A-\u0026gt;B}，R2的函数依赖F2={A-\u0026gt;C}，函数依赖F1并F2是不等价于分解前的函数依赖F的(缺少B-\u0026gt;C)，所以该分解没有保持函数依赖。第二问解析：R1的函数依赖F1={A-\u0026gt;B}，R2的函数依赖F2={D-\u0026gt;E}，函数依赖F1并F2是等价于分解前的函数依赖F的，所以该分解保持了函数依赖。\n有损无损分解\n有损：拆分后不能还原出原来的函数依赖。\n无损：拆分后可以还原出原来的函数依赖。指将一个关系模式分解成若干关系模式后，通过自然连接和投影运算仍能还原成原来的关系模式。\n判断是否无损分解一般可用表格法(通用方法)和公式法判断(本文不做介绍)。\n例题 学霸肯定对了 ↕ 无损分解\n解析：分解前为1NF，分解后满足BCNF。模式分解后保持了函数依赖。现在判断是否无损分解。\n用表格法比较清晰：\n1、构造初始表，列名是源属性集，行是分解后的关系模式，有值的给✅；\n2、找出表中的同名属性列，看它在原本函数依赖F中能决定出什么，如果有的话说明该函数依赖在分解后被保留下来了，就可以在各表的同名属性列决定的属性处打钩，如果没有就跳过；\n3、新决定出来的列可重新按上述规则重新判断下一个，以此类推，知道出现任意一行全部为钩则无损分解，若表格的所有属性都遍历完了也没有一行全为钩的，就是有损分解。\n具体为：初始表如下；同名属性列学号在原有函数依赖中决定了姓名，所以在学号为✅的行给姓名打✅；同名属性列姓名在源有函数依赖中没有决定任何属性，所以跳过；同名属性列课程号在原有函数依赖中决定了课程名，所以在课程号为✅的行给课程名打✅；此时满足任意一行(成绩)全为✅；所以它是无损分解。\n学霸肯定对了 ↕ D A\n解析参考上面例题的解析，思路完全一模一样。\n学霸肯定对了 ↕ A D\n解析参考上面例题的解析，思路完全一模一样。\n5.6 闭包 # 6 并发控制 # 6.1 事务 # 并发控制指的是事务的并发控制，事务保证了数据的完整性。事务有4个特点：简称ACID\n原子性(Atomicity) 是指事务包含的所有操作要么全部成功，要么全部失败回滚。这些操作是一个整体，不能部分地完成，跟操作系统的原语一样(PV操作)。\n一致性(Consistency) 是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。比如说转账。\n隔离性(Isolation) 是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。也就是执行的效果应该和串行一样互不影响。\n持久性(Durability) 是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，无论发送何种故障，都不应对其有任何影响。\n6.2 并发可能产生的问题 # 并发可能会产生以下问题：1、丢失更新；2、不可重复读问题；3、脏数据的读出。\n6.3 封锁协议 # 封锁协议是用来解决并发可能会产生的那三个问题。\nS封锁是读锁/共享锁(一个事务对操作对象上了读锁，另一个事务也可对该操作对象上读锁，这两个事务共享该操作对象)，X锁是写锁/排它锁(一个事务对操作对象上了写锁，那么其他任何事务都没法对该操作对象上任何锁，X锁具有排它性)。一级封锁协议可防止丢失更新；二级封锁协议可防止丢失更新和读脏数据；三级封锁协议可防止丢失更新、读脏数据和不可重复读问题。\n7 数据库的安全性 # 例题 学霸肯定对了 ↕ C\n索引和视图是无法更新的、存储过程是可以被第三方开发人员调用的，而触发器不行\n8 数据库的备份与恢复技术 # 8.1 数据备份 # 例题 学霸肯定对了 ↕ B 8.2 数据库故障与恢复 # 9 数据库性能优化 # 课后习题 # todo 数据库系统习题\n"},{"id":6,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/3-%E6%9E%B6%E6%9E%84%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/","title":"3) 架构描述语言","section":"3.10 软件架构设计","content":" 3.架构描述语言🏁 # ADL(Architect Describe Language)，它由三个基本的元素构成：\n1、构件：计算或者存储数据的单元。\n2、连接件：用于构件之间交互建模的连接块。\n3、架构配置：描述架构的构件与连接件的连接图。 学霸肯定对了 ↕ C "},{"id":7,"href":"/docs/example/architect-exam/3.4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","title":"3.4 计算机网络","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 ✌ # TCP/IP协议族 DHCP与DNS ✅✅✅ TCP与UDP ✅✅✅ 网络规划与设计 逻辑设计 ✅✅✅✅ 物理设计 ✅✅✅✅ 常见的网络设计 层次网络设计 ✅✅✅ 网络冗余设计 ✅✅ 网络存储 ✅ 各式网络存储架构 磁盘阵列容量计算 IPV6 ✅ 网络接入技术 综合布线 ✅ 网络技术扩展 物联网 ✅ 云计算 ✅ 1 TCP/IP协议族 # 1.1 TCP与UDP # 例题 学霸肯定对了 ↕ C\nA项窗口大小不是固定的，B项前项纠错一般自行纠错，后项纠错一般才要求重发；D项IP不是虚电路，而是走路由器。所以选C 1.2 DHCP与DNS # DNS(Domain Name System) 例题 学霸肯定对了 ↕ A 学霸肯定对了 ↕ C DHCP(Dynamic Host Configuration Protocol) 例题 学霸肯定对了 ↕ A 2 网络规划与设计 # 网络规划与设计包含5个阶段，它们分别是：需求分析、通信规范分析、逻辑网络设计、物理网络设计、实施阶段。这里重点看逻辑网络设计和物理网络设计，需求分析和通信规范分析的产物需要知道。\n2.1 逻辑网络设计 # 2.2 物理网络设计 # 例题 学霸肯定对了 ↕ A 学霸肯定对了 ↕ A 学霸肯定对了 ↕ A 学霸肯定对了 ↕ D 2.3 常见的网络设计 # 层次网络设计 例题 学霸肯定对了 ↕ A 学霸肯定对了 ↕ C 网络冗余设计 例题 学霸肯定对了 ↕ B 3 网络存储 # 各式网络存储架构 磁盘阵列容量计算 会计算Raid3和5的磁盘容量就行\n例题 学霸肯定对了 ↕ C 学霸肯定对了 ↕ B B 4 IPV6 # IPV6的特点 IPV4-\u0026gt;IPV6 IPV6地址合法性判断 例题 学霸肯定对了 ↕ C 5 网络接入技术 # 6 综合布线 # 例题 学霸肯定对了 ↕ C 7 网络技术扩展 # 7.1 物联网 # 感知层的关键技术 例题 学霸肯定对了 ↕ D 7.2 云计算 # 例题 学霸肯定对了 ↕ A 课后习题 # todo 计算机网络习题\n"},{"id":8,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/4-%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/","title":"4) 特定领域软件架构","section":"3.10 软件架构设计","content":" 特定领域软件架构 DSSA # DSSA全称为Domain Specific Software Architecture\\\n基本活动 \\ 领域分析机制 \\ 三层次模型 \\ 例题 学霸肯定对了 ↕ "},{"id":9,"href":"/docs/example/architect-exam/3.5-%E6%95%B0%E5%AD%97%E4%B8%8E%E7%BB%8F%E6%B5%8E%E7%AE%A1%E7%90%86/","title":"3.5 数字与经济管理","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 ✌ # 图论 最小生成树 ✅ 最短路径 ✅ 网络与最大流量 ✅ 运筹方法 线性规划 ✅ 动态规划 ✅✅✅ 预测与决策 ✅ 数学建模 ✅✅ 1 图论 # 1.1 最小生成树 # 学霸肯定对了 ↕ 23\n解题思路：按边看，依次找最小的变长将所有节点连接起来，不能有回路，及3-6，3-7，1-2，2-6，4-7，2-5，所以长度至少为2+3+3+4+5+6=23\n1.2 最短路径 # 学霸肯定对了 ↕ 81\n21+20+20+8+12=81，其他路径都比81大\n1.3 网络与最大流量 # 学霸肯定对了 ↕ 23\n10+6+5+1+1=23\n2 运筹方法 # 2.1 线性规划 # 学霸肯定对了 ↕ 设产品1为X，产品2位Y，立不等式，画图，最优解在顶点处，将顶点都带入目标式子，得到最值 2.2 动态规划 # 学霸肯定对了 ↕ B 2.3 预测与决策 # 学霸肯定对了 ↕ C\n解析：第一个月A=0.5，B=0.5，所以用(0.5,0.5) * 转移矩阵P，得到(0.6,0.4)，第二个月：(0.6,0.4) * 转移矩阵P=(0.64,0.36)，所以选C\n学霸肯定对了 ↕ C\n解析：设8点前有A人，来：x人/分钟，检票：y人/分钟，第二问开口最少为M，A+60x=60y * 8，A+40x=40y * 10，联立得到x=4y（来一波人开4个口），带入1式，得到A=240y，A+20x=20y*M，得到M=320y/20y=16\n学霸肯定对了 ↕ 甲乙都会选择降价策略 总结：乐观-\u0026gt;大中取大，悲观-\u0026gt;小中取大，后悔值-\u0026gt;大中取小 水路代价比较小\n学霸肯定对了 ↕ B\n加权平均值\n3 数学建模 # 课后习题 # todo 数字与经济管理习题\n"},{"id":10,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/5-%E5%9F%BA%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/","title":"5) 基于架构的软件开发","section":"3.10 软件架构设计","content":" 基于架构的软件开发ABSD # 基于架构的软件开发ABSD(Architecture-Based Software Design)。它能很好地支持重用。\n1、ABSD方法是架构驱动，即强调由业务、质量和功能需求的组合驱动架构设计。\n2、ABSD方法有三个基础。第一个基础是功能的分解。在功能分解中，ABSD方法使用已有的基于模块的内聚和耦合技术，第二个基础是通过选择架构风格来实现质量和业务需求，第三个基础是软件模板的使用。\n3、视角与视图:从不同的视角来检查，所以会有不同的视图。\n4、用例用来捕获功能需求、特定场景用来捕获质量需求。\n4.1 开发过程 # 4.1.1 架构需求 # 4.1.2 架构设计 # 4.1.3 架构文档化 # 4.1.4 架构复审 # 架构复审的目的是标识潜在的风险，及早发现架构设计中的缺陷和错误。\n4.1.5 架构实现 # 4.1.6 架构演化 # 例题 学霸肯定对了 ↕ 学霸肯定对了 ↕ "},{"id":11,"href":"/docs/example/architect-exam/3.6-%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7/","title":"3.6 系统配置与性能评价","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 ✌ # 性能指标 ✅ 阿姆达尔解决方案 ✅✅✅ 性能评价方法 ✅✅✅ 1 性能指标 # 字长：cpu一次读取数据的长度，它也影响着最大的内存容量(最大地址)。2^32 = 4G，32位操作系统最大支持4GB内存。\n主存容量和存取速度：存取速度和cache的命中率相关。\n运算速度：主频：(单位之间内的脉冲数)2.4GHz，主频=外频*倍频，CPU时钟周期：1/主频。\n吞吐量和吞吐率\n响应时间\n完成时间\n兼容性\n性能瓶颈调整 例题 学霸肯定对了 ↕ D A 2 阿姆达尔解决方案 # 例题 学霸肯定对了 ↕ 答案：B\n100/52\n学霸肯定对了 ↕ 答案：B\n求极限就行，1/0.1n\n3 性能评价方法 # 例题 学霸肯定对了 ↕ 答案：C A 学霸肯定对了 ↕ 答案：A B 学霸肯定对了 ↕ 答案：B 课后习题 # todo 补充课后习题\n"},{"id":12,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/6-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7/","title":"6) 软件质量属性","section":"3.10 软件架构设计","content":" 软件质量属性 # 1 性能 # 性能 (performance) 是指系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理的事件的个数。例如：\n1、同时支持1000并发；\n2、响应时间小于1ms；\n3、显示分辨率达到4k； 2 可用性 # 可用性(availability)是系统能够正常运行的时间比例。经常用两次故障之间的时间长度或在出现故障时系统能够恢复正常的速度来表示。例如：\n1、主服务器故障，一分钟内切换至备用服务器；\n2、系统故障，1小时内修复；\n3、系统支持 7 x 24 小时工作。 3 安全性 # 安全性(security)是指系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。安全性又可划分为机密性、完整性、不可否认性及可控性等特性。例如：\n1、可抵御sql注入攻击；\n2、对计算机的操作都有完整记录；\n3、用户信息数据库授权必须保证99.9%可用。 4 可修改性 # 可修改性(modifiability)是指能够快速地以较高的性能价格比对系统进行变更的能力。通常以某些具体的变更为基准，通过考察这些变更的代价衡量可修改性。例如：\n1、更改系统报表模块，2人在两周内必须完成；\n2、对Web界面风格进行修改，修改必须在2个月内完成。 例题 学霸做对了没 学霸做对了没\n基本不考的几个属性 # 可靠性、功能性、可变性、互操作性\n"},{"id":13,"href":"/docs/example/architect-exam/3.7-%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%8C%96/","title":"3.7 知识产权与标准化","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 ✌ # 保护范围与对象 ✅✅✅ 保护期限 ✅✅ 知识产权人确定 ✅✅✅ 侵权判定 ✅✅✅✅ 标准的分类 ✅ 标准代号的识别 ✅ 1 保护范围与对象 # 例题 学霸肯定对了 ↕ 答案：A 学霸肯定对了 ↕ 答案：C 学霸肯定对了 ↕ 答案：C 2 保护期限 # 例题 学霸肯定对了 ↕ 答案：B 学霸肯定对了 ↕ 答案：C 3 知识产权人确定 # 例题 学霸肯定对了 ↕ 答案：D 学霸肯定对了 ↕ 答案：A 学霸肯定对了 ↕ 答案：B 4 侵权判定 # 例题 学霸肯定对了 ↕ 答案：B 学霸肯定对了 ↕ 答案：A 学霸肯定对了 ↕ 答案：D 学霸肯定对了 ↕ 答案：A 学霸肯定对了 ↕ 答案：D 5 标准的分类 # 6 标准代号的识别 # 例题 学霸肯定对了 ↕ 答案：B 课后习题 # todo 补充课后习题\n"},{"id":14,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/7-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/","title":"7) 软件架构评估","section":"3.10 软件架构设计","content":" 软件架构评估 # 1. 名词解释 # 敏感点：是一个或多个构件 (和/或构件之间的关系)的特性。\n权衡点：是影响多个质量属性的特性，是多个质量属性的敏感点。\n风险点：是指架构设计中潜在的、存在问题的架构决策所带来的隐患。\n非风险点：是指不会带来隐患，一般以“xxx要求是可以实现 (或接受)的”方式表达。 2、架构评估方法 # 架构评估方法包含3中方式：基于问卷调查的方式、基于度量的方式、基于场景的方式。 2.1 基于场景的评估方法 # 基于场景的评估方法包含3种：软件架构分析法(SAAM)、架构权衡分析法(ATAM)、成本效益分析法(CBAM)。\nSAAM：最初用于分析架构可修改性，后扩展到其他质量属性。 ATAM：在SAAM的基础上发展起来的，主要针对性能、实用性、安全性和可修改性，在系统开发之前，对这些质量属性进行评价和折中。 2.2 质量效用数 # "},{"id":15,"href":"/docs/example/architect-exam/3.8-%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF%E5%8C%96%E6%88%98%E7%95%A5%E4%B8%8E%E5%AE%9E%E6%96%BD/","title":"3.8 企业信息化战略与实施","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 ✌ # 信息与信息化的概念 ✅ 信息系统生命周期 ✅ 信息系统战略规划 ✅✅✅ 政府信息化与电子政务 ✅ 企业信息化与电子商务 ✅✅✅ 企业门户 ✅✅ 企业应用集成 ✅✅✅ 1 信息与信息化概念 # 1.1 信息 # 香农(信息论)：信息就是不确定性的减少。\n维纳(控制论)：信息就是信息，既不是物质，也不是能量。(信息是可以转换成物质或者能量)\n特点 1.2 信息化 # 概念 信息化是从工业社会到信息社会的演进与变革。\n信息化的主体是全体社会成员 (政府、企业、团体和个人)，时域是一个长期过程,空域是经济和社会的一切领域，手段是先进社会生产工具。\n信息化对组织的意义 2 信息系统生命周期 # 单个系统的生命周期比较常考\n3 信息系统战略规划 # 方法论 第一阶段需求相对分散(销售部门有销售部门的系统，后勤部门有后勤部门的系统)。第二阶段围绕企业整体。第三阶段以集成为核心。第一阶段的每种方法(统称为BCS)都需要了解，二三阶段知道有哪些方法就行。\n3.1 关键成功因素法 CSF # 关键成功因素法(Critical Success Factors, CSF)\n3.2 战略集合转换法 SST # 战略集合转换法(Strategic Data Planning, SDP)\n3.3 企业系统规划法 BSP # 企业系统规划法(Business System Planning, BSP)\n例题 学霸肯定对了 ↕ 答案：B C 4 政府信息化与电子政务 # 主动与被动\n例题 学霸肯定对了 ↕ 答案：B A D C 5 企业信息化与电子商务 # 5.1 ERP # 特点 5.2 客户关系管理 # 5.3 供应链管理 # 5.4 电子商务 # 5.5 商业智能 BI # 数据仓库 数据挖掘 例题 学霸肯定对了 ↕ 答案：B 学霸肯定对了 ↕ 答案：C D B 数据湖 数据湖可以理解为数据库到数据仓库的中间状态\n业务流程重组BPR和业务流程管理BPM 6 企业门户 # 7 企业应用集成 # 集成支持的方式有3种。\n从不同的角度，可以将企业应用集成划分为3个方面。\n7.1 架构分层的角度 # 7.2 消息传递的角度 # 7.3 组织范围的角度 # 例题 学霸肯定对了 ↕ 答案：C 学霸肯定对了 ↕ 答案：C D 学霸肯定对了 ↕ 答案：C 课后习题 # todo 习题\n"},{"id":16,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/8-%E8%BD%AF%E4%BB%B6%E4%BA%A7%E5%93%81%E7%BA%BF/","title":"8) 软件产品线","section":"3.10 软件架构设计","content":" 软件产品线 # 1. 基本概念 # 2. 双生命周期模型 # 3. 建立方式 # 4. 组织结构 # "},{"id":17,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","title":"3.9 软件工程","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 软件开发方法 ✅✅✅ 软件开发模型 ✅✅✅✅ 净室软件/逆向工程 ✅ 需求工程 需求获取 ✅✅✅ 需求分析 ✅✅✅ UML4+1视图 ✅✅✅✅✅ UML图 ✅✅✅✅✅ UML关系 ✅✅✅✅✅ 系统设计 界面设计 ✅✅ 结构设计 ✅✅ 面向对象设计 ✅✅✅✅✅ 测试与评审 软件测试方法 | 多少星不知道 软件调试 | 多少星不知道 系统运行与软件维护 系统转换计划 | 多少星不知道 软件维护 | 多少星不知道 以工程化的思想来管理软件开发过程 # "},{"id":18,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/9-%E6%9E%84%E5%BB%BA%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/","title":"9) 构建与中间件技术","section":"3.10 软件架构设计","content":" 构件与中间件技术 # 1. 构件的定义 # 1、软件构件是一种组装单元，它具有规范的接口规约和显式的语境依赖。软件构件可以被独立地部署并由第三方任意地组装。\n2、构件是某系统中有价值的、几乎独立的并可替换的一个部分，它在良好定义的体系结构语境内满足某清晰的功能。\n3、构件是一个独立发布的功能部分，可以通过其接口访问它的服务。 特性\n构件系统体系结构由一组平台决策、一组构件框架和构件框架之间的互操作设计组成。\n构件框架是一种专用的体系结构 (通常围绕一些关键的机制)，同时，也是一组固定地作用于构件层次机制的策略。\n概念框架的互操作设计包括系统体系结构连接的所有框架间的互操作的规则。\n构件是一组通常需要同时部署的原子构件。构件和原子构件之间的区别在于，大多数原子构件永远都不会被单独部署，尽管它们可以被单独部署。\n一个原子构件是一个模块和一组资源。\n模块是一组类和可能的非面向对象的结构体，比如过程或者函数。\n资源是一个类型化的项的固定集合。\n资源这个概念可以包含代码资源，进而包含模块。问题在干除了编译器编译一个模块或包生成的资源外，还可能存在其他的资源。在“纯对象”的方法。\n中，资源是外部化的不可改变的对象一一不可改变是因为构件没有持久化的标志，而目复制不能被区分。 2. 中间件 # 中间件是一类构件、中间件是一类系统软件 中间件技术的优点： 3. 构件的复用 # "},{"id":19,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/10-web%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","title":"10) web架构设计","section":"3.10 软件架构设计","content":" web架构设计 # "},{"id":20,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","title":"3.10 软件架构设计","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 软件架构的概述 ✅✅✅ 软件架构风格 ✅✅✅✅✅ 架构描述语言 ✅✅✅ 特定领域软件架构 ✅✅✅ 基于架构的软件开发 ✅✅✅✅ 软件质量属性 ✅✅✅✅✅ 软件架构评估 ✅✅✅✅✅ 软件产品线 ✅✅✅ 构建与中间件技术 ✅✅✅✅ web架构设计 ✅✅✅✅✅ "},{"id":21,"href":"/docs/example/architect-exam/3.11-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/","title":"3.11 系统安全分析与设计","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 安全基础技术 对称与非对称加密 ✅✅✅ 数字签名 ✅✅✅ 信息摘要 ✅✅✅ 网络安全 安全协议 ✅✅✅ 网络攻击 ✅✅ 等级保护标准 ✅✅ 课后习题 # todo 习题\n"},{"id":22,"href":"/docs/example/architect-exam/3.12-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/","title":"3.12 系统可靠性分析与设计","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 可靠性相关基本概念 ✅✅ 系统可靠性分析 ✅✅✅✅ 系统可靠性设计 ✅✅✅✅ 课后习题 # todo 习题\n"},{"id":23,"href":"/docs/example/architect-exam/3.13-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/","title":"3.13 项目管理","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 立项管理 ✅ 范围管理 ✅✅ 时间管理 ✅✅✅✅ 成本管理 ✅ 软件质量管理 ✅✅ 软件配置管理 ✅✅ 课后习题 # todo 习题\n"},{"id":24,"href":"/docs/example/architect-exam/3.14-%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD/","title":"3.14 专业英语","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 历年真题 1 2009年 # 原文 An architectural style defines as a family of such systems in terms of a ( 1 ) of structural organization. More specifically, an architectural style defines a vocabulary of ( 2 ) and connector types， and a set of ( 3 ) on how they can be combined. For many styles there may also exist one or more ( 4 ) that specify how to determine a system’s overall properties from the properties of its parts.Many of architectural styles have been developed over the years. The best-known examples of ( 5 ) architectures are programs written in the Unix shell.\n(1) A.pattern B.data flow C.business process D.position level\n(2) A.metadata B.components C.models D.entities\n(3) A.functions B.code segments C.interfaces D.constraints\n(4) A.semantic models B.weak entities C.data schemas D.business models\n(5) A.event-based B.object-oriented C.pipe-and-filter D.Layered\n学霸肯定对了 ↕ A B D\n架构风格以一种结构化组织模式定义一组这样的系统。具体来说，一种架构风格定义了一个构件及连接器类型的词汇表，以及一组关于它们如何能够被关联的约束对于许多风格来说，可能也存在一个或多个语义模型，从系统部件的特性来确定系统的整体特性。许多架构风格已经发展了很多年，众所周知的管道-过滤器架构的例子就是用 UNIX shell 编写的程序。\npattern:模式\nmetadata:元数据\nsegments:部分\nconstraints:约束\nsemantic:语义\nschemas:模式，图式，计划\nlayered:分层的\nin terms of:在\u0026hellip;方面，按照\n2 2010年 # 原文 The software architecture is a set of software components, subsystems, relationships， interactions, the properties of each of these elements， and the set of guiding principles that together constitute the fundamental properties and constraints of a software system or set of systems. ( 1 ) defines a general set of element types and their interactions. The examples include Pipes and Filters, Model-View-Controller, and Reflection. A ( 2 ) in software architecture is a representation used to understand or document one or more aspects of a problem or solution. Architecture is usually used in conjunction with many adjunct terms. The ( 3 ) defines the key strategies, organization, goals and related processes of the enterprise. At the enterprise level, the ( 4 ) may be more of a set of guidelines on how the various software architectures should be constructed consistently across the enterprise. The ( 5 ), which describes the high-level set of elements involved in application from a particular domain along with their Interactions, is often used to focus on subsystem definition rather than application process level definition.\n(1) A.Architectural pattern B.Architectural description C.Architectural view D.Architectural viewpoint\n(2) A.model B.domain C.component D.subsystem\n(3) A.enterprise architecture B.technical architecture C.infrastructure architecture D.business architecture\n(4) A.enterprise architecture B.data architecture C.application architecture D.information architecture\n(5) A.product-line architecture B.reference architecture C.technology architecture D.infrastructure architecture\n学霸肯定对了 ↕ A、A、D、C、B\n软件架构是一组软件构件、子系统、关联关系、交互关系以及其中每个元素的特性和一 组指导原则，这些共同构成一个软件系统或一组系统的基本特性和约束。架构模式定义了一 组通用的元素类型及其交互关系。其中的例子包括 Pipes and Filters、MVC 和 Reflection。软 件架构中的模型是一种表现形式，用于从一个或多个方面理解或记录一个问题或解决方案。 架构通常会与一些附属词结合起来使用。业务架构定义了企业的关键策略、组织、目标和相 关过程。在企业层面，应用架构可能更多的是一组关于应该如何在整个企业一致地构建各种 软件架构的指导原则。参考架构描述了源自特定领域的应用涉及的高层元素集合及其交互关 系，通常用于关注子系统的定义而不是应用过程级别定义。\nInfrastructure:基础设施\n3 2011年 # 原文 Information systems design is defined as those tasks that focus on the specification of a detailed computer-based solution. Typically, there are four systems design tasks for in-house development.\n1) The first task is to specify ( 1 ), which defines the technologies to be used by one, more, or all information systems in terms of their data, processes, interfaces, and network components. This task is accomplished by analyzing the data models and process models that are initially created during requirements analys16.\n2) The next systems design task is to develop the ( 2 ). The purpose of this task is to prepare technical design specifications for a database that will be adaptable to future requirements and expansion.\n3) Once the database prototype has been built, the systems designer can work closely with system users to develop input, output and dialogue specifications. The ( 3 ) must be specified to ensure that the outputs are not lost, misrouted, misused, or incomplete.\n4) The fourth design task involves packaging all the specifications from the previous design tasks into a set of specifications that will guide the ( 4 ) activities during the following phases of the systems development methodology. Finally, we should( 5 ) and update the project plan accordingly. The key deliverable should include a detailed plan for the construction phase that should follow.\n(1) A. an application architecture B. a distributed system C. a system scope D. a system physical model\n(2) A. database design specifications B. database organization decisions C. data structure specifications D. data distribution decisions\n(3) A. format and layout B. transaction details C. additional instructions D. internal controls\n(4) A. system administrator’s B. system analyst’s C. computer programmer’s D. system designer’s\n(5) A. adjust the project schedule B. reevaluate project feasibility C. evaluate vendor proposals D. select the best vendor proposal\n学霸肯定对了 ↕ A、A、D、C、B\n信息系统设计被定义为一些任务，它们主要关注一个详细的计算机解决方案的规格说 明。通常来说，内部开发有四种系统设计任务。\n(1)第一项任务是确定一个应用程序架构，它以数据、过程、接口和网络组件的方式 定义一个、多个或所有信息系统要使用的技术。完成这项任务需要分析最初创建于需求分析 期间的数据模型和过程模型。\n(2)下一项系统设计任务是开发数据库设计的规格说明。该任务的目的是准备一个数 据库技术设计规格说明，以适应将来的需求和扩展。\n(3)一旦建成了数据库原型，系统设计入员能够和系统用户密切合作开发输入、输出 和对话框规格说明。必须指定内部控件来确保输出不会丢失、误传、滥用或不完整。\n(4)第四项设计任务包括把之前所有设计任务的规格说明打包为一套规格说明，将在 系统开发方法的后续阶段中指导计算机程序员的活动。 最后，我们应该重新评估项目的可行性并相应地更新项目计划。主要交付成果将包括构 建阶段应该遵循的一个详细计划。\nSpecifications(规格)\ninternal(内部的)\n4 2012年 # 原文 An application architecture specifies the technologies to be used to implement one or more information systems. It serves as an outline for detailed design, construction, and implementation. Given the models and details, include( 1 ), we can distribute data and processes to create a general design of application architecture. The design will normally be constrained by architecture standards, project objectives, and ( 2 ). The first physical DFD to be drawn is the( 3 ). The next step is to distribute data stores to different processors. Data( 4 ) are two types of distributed data which most RDBMSs support. There are many distribution options used in data distribution. In the case of ( 5 ) we should record each table as a data store on the physical DFD and connect each to the appropriate server.\n(1) A.logical DFDs and ERD B.ideal object model and analysis class model C.use case models and interface prototypes D.physical DFDs and database schema\n(2) A.the database management system B.the feasibility of techniques used C.the network topology and technology D.the user interface and process methods\n(3) A.context DFD B.system DFD C.network architecture DFD D.event-response DFD\n(4) A.vertical partitioning and horizontal replication B.vertical replication and horizontal partitioning C.integration and distribution D.partitioning and replication\n(5) A.storing all data on a single server B.storing specific tables on different servers C.storing subsets of specific tables on different servers D.duplicating specific tables or subsets on different servers\n学霸肯定对了 ↕ A、B、C、B、D\n应用架构说明了实现一个或多个信息系统所使用的技术，它作为详细设计、构造和实现 的一个大纲。给定了包括逻辑数据流图和实体联系图在内的模型和详细资料，我们可以分配 数据和过程以创建应用架构的一个概要设计。概要设计通常会受到架构标准、项目目标和所 使用技术的可行性的制约。需要绘制的第一个物理数据流图是网络架构数据流图。接下来是 分配数据存储到不同的处理器。数据分区和复制是大多数关系型数据库支持的两种分布式数 据形式。有许多分配方法用于数据分布。在不同服务器上存储特定表的情况下，我们应该将 每个表记为物理数据流图中的一个数据存储，并将其连接到相应的服务器\n5 2013年 # 原文 A system\u0026rsquo;s architecture is a representation of a system in which there is a mapping of( 1 ) onto hardware and software components, a mapping of the ( 2 ) onto the hardware architecture. and a concern for the human interaction with these components. That is, system architecture is concerned with a total system, including hardware. software, and humans. Software architectural structures can be divided into three major categories, depending on the broad nature of the elements they show.\nI):( 3 ) embody decisions as a set of code or data units that have to be constructed or procured.\nII): ( 4 ) embody decisions as to how the system is to be structured as set of elements that have runtime behavior and interactions.\nIII): ( 5 ) embody decisions as to how the system will relate to nonsoftware structures in its environment(such as CPUs, file systems, networks, development teams, etc.).\n(1) A.attributes B.constraint C.functionality D.requirements\n(2) A.physical components B.network architecture C.software architecture D.interface architecture\n(3) A.Service structures B.Module structures C.Deployment structures D.Work assignment structures\n(4) A.Decompostion structures B.Layer structures C.Implementation structures D.Component-and-connector structures\n(5) A.Allocation structures B.Class structures C.Concurrency structures D.Uses structures\n学霸肯定对了 ↕ C、C、B、D、A\n系统架构是一个系统的一种表示，包含了功能到软硬件构件的映射、软件架构到硬件架构的映射以及对于这些组件人机交互的关注。也就是说，系统架构关注于整个系统，包括硬 件、软件和使用者。软件架构结构根据其所展示元素的广义性质，可以被分为三个主要类别。\n1)模块结构将决策体现为一组需要被构建或采购的代码或数据单元。\n2)构件连接器结构将决策体现为系统如何被结构化为一组具有运行时行为和交互的元 素。\n3)分配结构将决策体现为系统如何在其环境中关联到非软件结构，如 CPU、文件系 统、网络、开发团队等。\nConstraint:约束\nStructure:架构\nConcurrency:并发。\n6 2014年 # 原文 Software architecture reconstruction is an interpretive, jnteractive, and iterative process including many activities. ( 1 ) involves analyzing a system\u0026rsquo;s existing design and implementation artifacts to construct a model of it. The result is used in the following activities to construct(结构) a view of the system. The database construction activity converts the ( 2 ) contained in the view into a standard format for storage in a database. The ( 3 ) activity involves defining and manipulating( 控 制 ) the information stored( 存 储 的 ) in database to reconcile, augment(增强), and establish(建立) connections between the elements. Reconstruction consists of two primary activities: ( 4 ) and ( 5 ). The former provides a mechanism for the user to manipulate architectural elements, and the latter provides facilities for architecture reconstruction.\n(1) A.Reverse engineering B.Information extraction C.Requirements analysis D.Source code analysis\n(2) A.actors and use cases B.processes and data C.elements and relations D.schemas and tables\n(3) A.database normalization B.schema definition C.database optimization D.view fusion\n(4) A.architecture analysis and design B.domain analysis and static modeling C.visualization and interaction D.user requirements modeling\n(5) A.pattern definition and recognition B.architecture design and implementation C.system architecture modeling D.dynamic modeling and reconstruction\n学霸肯定对了 ↕ B、C、D、C、A\n软件架构重用是一个解释性、交互式和反复迭代的过程，包括了多项活动。信息提取通 过分析系统现有设计和实现工件来构造它的模型。其结果用于在后续活动中构造系统的视 图。数据库构建活动把模型中包含的元素和关系转换为数据库中的标准存储格式。视图融合 活动包括定义和操作数据库中存储的信息，理顺、加强并建立起元素之间的连接。重构由两 个主要活动组成;可视化和交互及模式定义和识别。前者提供了一种让用户操作架构元素的 机制，后者则提供了用于架构重构的设施。\n7 2015年 # 原文 The objective of ( 1 ) is to determine what parts of the application software will be assigned to what hardware.The major software components of the system being developed have to be identified and then allocated to the various hardware components on which the system will operate. All software systems can be divided into four basic functions. The first is( 2 ). Most information systems require data to be stored and retrieved,whether a small file,such as a memo produced by a word processor,or a large database,such as one that stores an organization’s accounting records. The second function is the ( 3 ),the processing required to access data,which often means database queries in Structured Query Language. The third function is the ( 4 ),which is the logic documented in the DFDs,use cases,and functional requirements.The fourth function is the presentation logic,the display of information to the user and the acceptance of the user’s commands.The three primary hardware components of a system are ( 5 ). (1) A.architecture design B.modular design C.physical design D.distribution design\n(2) A.data access components B.database management system C.data storage D.data entities\n(3) A.data persistence B.data access objects C.database connection D.dataaccess logic\n(4) A.system requirements B.system architecture C.application logic D.application program\n(5) A.computers,cables and network B.clients,servers,and network C.CPUs,memories and I/O devices D.CPUs,hard disks and I/O devices\n学霸肯定对了 ↕ A、C、D、C、B\n架构设计的目标是确定应用软件的哪些部分将分配到何种硬件。识别出正在开发系统的主要软件构件并分配到系统将要运行的硬件构件。所有软件系统可分为四项基本功能。第一 项是数据存储。大多数信息系统需要数据进行存储并检索，不论是一个小文件，比如一个字 处理器产生的一个备忘录，还是一个大型数据库，比如存储一个企业会计记录的数据库。第 二项功能是数据访问逻辑，处理过程需要访问数据，这通常是指用 SQL 进行数据库查询。 第三项功能是应用程序逻辑，这些逻辑通过数据流图，用例和功能需求来记录。第四项功能 是表示逻辑，给用户显示信息并接收用户命令。一个系统的三类主要硬件构件是客户机、服务器和网络。\n8 2016年 # 原文 The objective of ( 1 ) is to determine what parts of the application software will be assigned to what hardware. The major software components of the system being developed have to be identified and then allocated to the various hardware components on which the system will operate. All software systems can be divided into four basic functions. The first is ( 2 ). Most information systems require data to be stored and retrieved, whether a small file,such as a memo produced by a word processor, or a large database, such as one that stores an organization’s accounting records.The second function is the ( 3 ), the processing required to access data, which often means database queries in Structured Query Language. The third function is the ( 4 ),which is the logic documented in the DFDs, use cases,and functional requirements.The fourth function is the presentation logic,the display of information to the user and the acceptance of the user’s commands.The three primary hardware components of a system are ( 5 ).\n(1) A.architecture design B.modular design C.physical design D.distribution design\n(2) A.data access components B.database management system C.data storage D.data entities\n(3) A.data persistence B.data access objects C.database connection D.data access logic\n(4) A.system requirements B.system architecture C.application logic D.application program\n(5) A.computers,cables and network B.clients,servers,and network C.CPUs,memories and I/O devices D.CPUs,hard disks and I/O devices\n学霸肯定对了 ↕ A、C、D、C、B\n架构设计的目标是确定应用软件的哪些部分将分配到何种硬件。识别出正在开发系统的主要软件构件并分配到系统将要运行的硬件构件。所有软件系统可分为四项基本功 能。第一项是数据存储。大多数信息系统需要数据进行存储并检索，不论是一个小文件，比 如一个字处理器产生的一个备忘录，还是一个大型数据库，比如存储一个企业会计记录的数 据库。第二项功能是数据访问逻辑，处理过程需要访问数据，这通常是指用 SQL 进行数据 库查询。第三项功能是应用程序逻辑，这些逻辑通过数据流图，用例和功能需求来记录。第 四项功能是表示逻辑，给用户显示信息并接收用户命令。一个系统的三类主要硬件构件是客 户机、服务器和网络。\n9 2017年 # 原文 The architecture design specifies the overall architecture and the placement of software and hardware that will be used. Architecture design is a very complex process that is often left to experienced architecture designers and consultants. The first step is to refine the ( 1 ) into more detailed requirements that are then employed to help select the architecture to be used and the software components to be placed on each device. In a ( 2 ), one also has to decide whether to use a two-tier,three-tier,or n-tier architecture. Then the requirements and the architecture design are used to develop the hardware and software specification. There are four primary types of nonfunctional requirements that can be important in designing the architecture. ( 3 ) specify the operating environment(s) in which the system must perform and how those may change over time. ( 4 ) focus on the nonfunctional requirements issues such as response time, capacity, and reliability. ( 5 ) are the abilities to protect the information system from disruption and data loss, whether caused by an intentional act. Cultural and political requirements are specific to the countries in which the system will be used.\n(1) A. functional requirements B. nonfunctional requirements C. system constraint D. system operational environment\n(2) A. client-based architecture B. server-based architecture C. network architecture D. client-server architecture\n(3) A. Operational requirements B. Speed requirement C. Access control requirements D. Customization requirements\n(4) A. Environment requirements B. Maintainability requirements C. Performance requirements D. Virus control requirements\n(5) A. Safety requirements B. Security requirements C. Data management requirements D. System requirements\n学霸肯定对了 ↕ B、D、A、C、B\n架构设计指定了将要使用的软件和硬件的总体架构和布局。架构设计是一个非常复杂的过程，往往留给经验丰富的架构设计师和顾问。第一步是将(71)细化为更详细的要求，然 后用于帮助选择要使用的体系结构以及要放置在每个设备上的软件组件。在(72)中，还必须决定是使用两层，三层还是 n 层架构。 然后使用需求和体系结构 设计来开发硬件和软件规范。有四种主要的非功能需求类型可能在设计架构时非常重要。 (73)指定系统必须执行的操作环境以及这些操作环境如何随时间变化。(74)侧重于非功 能性需求问题，如响应时间，容量和可靠性。(75)是否有能力保护信息系统免受故意行为 造成的破坏和数据丢失。文化和政治要求是特定于系统将被使用的国家。\nfunctional requirements(功能需求)\nnonfunctional requirements (非功能需求)\nsystem constraint (系统约束)\nsystem operational environment (系统操作环境)\nclient-based architecture (基于客户端的架构)\nserver-based architecture(基于服务器的架构)\nnetwork architecture (网络架构)\nclient-server architecture (客户端-服务器架构)\noperational requirements (操作要求)\nspeed requirements (速度要求)\nAccess control requirements (访问控制要求)\ncustomization requirements (用户要求)\nenvironment requirements (环境要求)\nMaintainability requirements (可维护性要求)\nperformance requirements (性能要求)\nvirus control requirements(病毒控制要求)\nsafety requirements (安全要求)\nsecurity requirements(安全要求)\nData management requirements (数据管理要求)\nsystem requirements(系统要求)\n10 2018年 # 原文 Designing the data storage architecture is an important activity in system design. There are two main types of data storage formats: files and databases. Files are electronic of data that have been optimized to perform a particular transaction. There are several types of files that differ in the way they are used to support an application.(71)store core information that is important to the business and , more specifically , to the application , such as order information or customer mailing information . (72)contain static values , such as a list of valid codes or the names of cities . Typically, the list is used for validation. A database is a collection of groupings of information that are related to each other in some way. There are many different types of databases that exist on the market today.(73)is given to those databases which are based on older , sometimes outdated technology that is seldom used to develop new applications . (74)are collections of records that are related to each other through pointers In relational database , (75)can be used in ensuring that values linking the tables together through the primary and foreign keys are valid and correctly synchronized.\n(71) A.Master files B.Look-up files. C.Transaction files D.History files\n(72) A.Master files B.Look-up files C.Audit files D.History files\n(73) A.Legacy database B.Backup database C. Multidimensional database D. Workgroup database\n(74) A.Hierarchical database B. Workgroup database C. Linked table database D. Network database\n(75) A.identifying relationships B. normalization C.referential integrity D.store procedure\n学霸肯定对了 ↕ A C A A C 11 2019年 # 原文 During the systems analysis phase , you must decide how data will be organized, stored.and manage D. A( 1 )is a framework for organizing, storing, and managing datEach file or table contains data about people, places, things, or events. One of the potentiaproblems existing in a file processing environment is ( 2 ), which means that data common totwo or more information systems is stored in several places.In a DBMS, the linked tables form a unified data structure that greatly improves dataquality and access. A(n) ( 3 ) is a model that shows the logical relationships and interactionamong system entities . It provides an overall view of the system and a blueprint for creatingthe physical data structures. ( 4 ) is the process of creating table designs by assigning specificfields or attributes to each table in the database. A table design specifies the fields andidentifies the primary key in a particular table or file. The three normal forms constitute aprogression in which( 5 )represents the best design. Most business-related databases must bedesigned in that form\n(1) A. data entity B. data structure C.file collection D. data definition\n(2) A. data integrity B. the rigid data structure C.data redundancy D.the many-to-many relationship\n(3) A. entity-relationship diagram B. data dictionary C. database schema D. physical database model\n(4) A. Normalization B. Replication C. Partitioning D. Optimization\n(5) A. standard notation form B. first normal form C. second normal form D. third normal form\n学霸肯定对了 ↕ B、C、A、A、D\n在系统分析阶段，需要确定数据如何组织、存储和管理。数据结构是用于组织、存储和管理数据的一个框架。每个文件或表中包含了关于人物、地点、事物和事件的数据。文件处理场景中存在的潜在问题之一是数据冗余，意味着两个或多个信息系统中相同的数据存储在 多个不同位置。在关系数据库管理系统 (DBMS) 中，相互链接的表格形成了一个统一的数据结构，可以大大提升数据质量和访问。实体联系图是一个模型，显示了系统实体之间的逻辑关系和交互。它提供了一个系统的全局视图和用于创建物理数据结构的蓝图。规范化是通过为数据库中的每个表分配特定的字段或属性来创建表设计的过程。表设计是在特定表或文件中确定字段并标识主关键字。三种范式构成了一个序列，其中第三范式代表了最好的设计，大部分与业务相关的数据库必须设计成这种形式。\n12 2020年 # 原文 The purpose of systems design is to specify a(n) ( 1 ), which defines the technologies to be usedto build the proposed information systems. This task is accomplished by analyzing the datamodels and process models that were initially created during ( 2 ) . The ( 3 ) is used to establishphysical processes and data stores across a network. To complete this activity, the analyst mayinvolve a number of system designers and ( 4 ) , which may be involved in this activity to helpaddress business data, process, and location issues. The key inputs to this task are the facts,recommendations, and opinions that are solicited from various sources and the approved ( 5 ) fromthe decision analysis phase.\n(1) A.physical model B.prototype system C.database schema D.application architecture\n(2) A.requirements analysis B.problem analysis C.cause-effect analysis D.decision analysis\n(3) A.entity-relationship diagram B.physical data flow diagram C.data flow diagram D.physical database model\n(4) A.system users B.system analyst C.system owner D.project manager\n(5) A.system architecture B.system proposal C.technical model D.business procedure\n学霸肯定对了 ↕ D.A.B.A.B\n系统设计的目的是指定一种 ()，它定义了用于构建拟议信息系统的技术。此任务通过分析最初在 ()期间创建的数据模型和流程模型来完成。() 用于跨网络建立物理过程和数据存储。为了完成这项活动，分析师可能会让许多系统设计师和 () 参与这项活动，以帮助解决业务数据、流程和位置问题。这项任务的关键输入是从各种来源征求的事实、建议和意见，以及决策分析阶段获得的批准 ()。\n第1题:A、物理模型 B、原型系统 C、数据库模式 D、应用体系架构\n第2题:A、需求分析 B、问题分析 C、因果分析 D、决策分析\n第3题:A、实体联系图 B、物理数据流图 C、数据流图 D、物理数据库模型\n第4题:A、系统用户 B、系统分析师 C、系统所有者 D、项目经理\n第5题:A、 系统架构 B、系统建议书 C、技术模型 D、 业务流程\n13 2021年 # 原文 The prevailing distributed computing model of the current era is called client/server computing. A( 1 )is a solution in which the presentation,presentation logic,applicatio nlogic,data manipulation and data layers are distributed between client PCs and one o r moreservers. A( 2 ) is a personal computer that does not have to be very powerfu lin terms ofprocessor speed and memory because it only presents the interface to th e user. A( 3 )is apersonal computer.notebook computer,or workstation that is typic ally more powerful interms of processor speed,memory,and storage capacity. A(n)( 4 )hosts one or more shareddatabase but also executes all database commands and s ervices for information systems. A(n) ( 5 ) hosts Internet or intranet Web sites,it co mmunicates with clients by returning tothem documents and data.\n(1) A. Client/Server system B.Client-side C.Serve-sider D.Database\n(2) A. Serve-sider B.Browser C. Fat client D.Thin client\n(3) A. Cloud platform B. Cluster system C. Fat client D.Thin client\n(4) A.Transaction server B. Database serverer C.Application server D.Message server\n(5) A. Database server B.Message server C.Web server D.Application server\n学霸肯定对了 ↕ A、D、C、B、C\n现在主流的分布式计算是客户/服务器计算模式。客户/服务器系统是一种解决方案，其中表示层、表示逻辑层、应用逻辑、数据操作、数据层分布在客户的PC 端与一个或多个服务器端之间。瘦客户端指的是个人电脑在处理速度、内存方面无须很强大，因为它仅仅是展示接口给用户。胖客户端是指个人电脑、笔记本、工作站在处理速度、内存、存储容量方面都很强大的一类电脑。数据库服务器控制一个或多个共享数据库，同时也执行所有数据库命令以及服务于信息系统。web 服务器控制互联网、信息平台，与客户端通信，返回给客户端文件与数据。\n14 2022年 # 原文 Micro-service is a software development technology, which advocates dividing a single applicationinto a group of small services，which coordinates and cooperates with each other to provide ultimatevalue for users.The micro-service ( 1 ) has many important benefits.First, it solves the problem ofbusiness complexity.It decomposes the original huge single application into a group ofservices.Although the total amount of functions remains the same, the application has beendecomposed into manageable services.The development speed of a single service is much faster,and it is easier to understand and ( 2 ) Second.this architecture allows each service to be ( 3 ) independently by a team.Developers are free to choose any appropriate technology.Third,themicro-service architecture mode enables each service to be ( 4 )independently.Developers never needto coordinate the deployment of local changes to their services.These types of changes can bedeploved immediately after testing.Finally.the micro-service architecture enables each service to ( 5 ) independently.\n(1) A、architecture B、software C、application D、technology\n(2) A、develop B、maintain C、utilize D、deploy\n(3) A、planned B、developed C、utilized D、deployed\n(4) A、utilized B、developed C、tested D、deployed\n(5) A、analyze B、use C、design D、expand\n学霸肯定对了 ↕ 课后习题 # todo 习题\n"},{"id":25,"href":"/docs/example/architect-exam/3.15-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%93%E6%A0%8F/","title":"3.15 案例分析专栏","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 时间管理与成本管理 ✅✅✅✅ 系统安全性 ✅✅ 系统可靠性 ✅✅ 课后习题 # todo 习题\n"},{"id":26,"href":"/docs/example/architect-exam/3.16-%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E4%B8%93%E6%A0%8F/","title":"3.16 论文写作专栏","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 课后习题 # todo 习题\n"},{"id":27,"href":"/docs/example/golang/","title":"1. golang - 从入门到入土","section":"介绍","content":" 持续更新ing # "},{"id":28,"href":"/docs/example/gin/","title":"2. gin杂谈","section":"介绍","content":" 持续更新ing # "},{"id":29,"href":"/docs/example/architect-exam/","title":"3. 高级软考 - 系统架构师","section":"介绍","content":" 本博客只介绍“高级资格”里面的系统架构师，想考别的科目的朋友请参见官网 软考 1、考试介绍 # 系统架构师考试包含：3个科目，满分均为75分，45分为过线，需三科同时过线才算考过。 2、考试时间 # 每年具体那天考试不太确定，大概都是11月份。科目一全为选择题、科目二为案例分析题(第1道必答，后4道题选答2道，总共做3个题)、科目三论文作(四选一，不排除之后会变成二选一) 3、报名地址 # 需要格外注意的是：每个科目、每个省份的报名时间是不一样的，大概会在每年的4月和10月左右。系统架构师大概会在每年的10月左右。官方网站 软考\n4、考试内容 # 架构师考试内容太宽泛了，如果你和我一样是工作了才准备考的话，建议复习重点，45分和75分没啥区别 5、笔者过没过 # 算是比较幸运，我是一把过。希望学弟学妹们都能一把过。 6、备考资料 # 笔者的资料是从机构高价买的，现低价有偿分享给大家，所有资料打包 30元 即可获取，微信号：wys837，博主唯一的恰饭来源 😅\n资料主要有：\n2009-2022年的按年的真题及详细解析； 2009-2022年的按知识点的真题及详细解析； 新版系统架构师教材(2022年11月出版)，鉴别新版教材tips：新版教材分上下篇，总共20个章节； 某塞新版教材分析视频； 刷题小程序(非常适合上班族)； 按章节的知识点和真题排班的所有例题； 思维导图； 22年某赛讲义配套视频(309集，总共约48个小时的视频)； 相关的重要知识点补充、案例分析必背题目、示例论文精读、某赛讲义(我主要的复习参考)、答题卡等等。 "},{"id":30,"href":"/docs/example/algorthem/","title":"4. 数据结构与算法","section":"介绍","content":" 持续更新ing # "},{"id":31,"href":"/docs/example/leetcode/","title":"5. leetcode","section":"介绍","content":" 持续更新ing # github地址：https://github.com/yswang837/golang-leetcode\n"},{"id":32,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/11-%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/","title":"11) 专项练习","section":"3.10 软件架构设计","content":"todo 补充课后习题\n1. 架构基础知识 # 2. 软件架构概念 # 在讲义312页\n"},{"id":33,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/1-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/","title":"1) 软件开发方法","section":"3.9 软件工程","content":" 软件开发方法 ✌ # 常见的软件开发方法有4种：结构化法、面向对象方法、面向服务方法、原型法。\n软件开发方法比软件开发模型大一号，开发方法下面可以挂载开发模型。\n整体图示如下图：\n1 结构化法 # 用户至上；\n严格区分工作阶段，每个阶段有任务和结果；\n强调系统开发过程的整体性和全局性；\n系统开发过程工程化，文档资料标准化；\n自顶向下，逐步分解(求精)。\n2 面向对象方法 # 更好的复用性；\n关键在于建立一个全面、合理、统一的模型；\n分析、设计、实现三个阶段，界限不明确。\n3 面向服务方法 # SOA方法有三个主要的抽象级别：操作、服务、业务流程；\nSOA分为三个层次：基础设计层(底层服务构件)、应用结构层(服务之间的接口和服务级协定)和业务组织层(业务流程建模和服务流程编排)；\n服务建模：分为服务发现、服务规约和服务实现三个阶段。\n4 原型法 # 适用于需求不明确的开发；一般主要用于需求分析阶段；可以和另外3中开发方法打配合。\n包括抛弃型原型和进化型原型。\n5 其他软件开发方法 # 形式化方法：所有东西均可证明/验证，而不是代码测试；\n统一过程方法UP；\n敏捷开发方法；\n基于架构的开发方法ABSD。\n例题 学霸肯定对了 ↕ D A B "},{"id":34,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/2-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/","title":"2) 软件开发模型","section":"3.9 软件工程","content":" 软件开发模型 ✌ # 一个开发方法下面可以有多个开发模型。\n1 瀑布模型 # 严格先后完成每个阶段，上一阶段的输出时下一个阶段的输入，是结构化开发方法的典型模型，适合于需求明确的项目，对大型项目来说风险较大。\n2 迭代/演化模型 # 先快速开发出一个能用的简版的模型，之后再进行完善和优化。\n3 增量模型 # 先开发出最核心的组件，之后在再核心组件上开发出别的组件。\n4 螺旋模型 # 螺旋模型 = 原型 + 瀑布模型，首次引入风险分析，适合大型项目。\n例题 学霸肯定对了 ↕ B 5 原型模型 # 适合需求不明确的系统。若题目中指明“需求不明确”，选原型而不选螺旋模型。\n6 喷泉模型 # 早期著名的面向对象模型。\n7 V模型 # 结构化模型；测试提前做，测试贯穿于始终。\n8 构建组装模型 # 优点：快，成本低、可靠。\n缺点：构建库的建立需要慢慢积累。\n9 快速应用开发模型RAD # 快速应用开发=瀑布模型(SDLC) + 构建组装模型(CBSD)\n10 统一过程模型UP/RUP # 三大特点：用例驱动、以架构为中心、迭代和增量。\n四个阶段： 初始：确定项目范围和边界 细化：设计并确定架构体系 构建：开发剩余的构建、构建组装与测试 交付：制作发布版本 例题 学霸肯定对了 ↕ B A 11 敏捷开发模型 # 小步快跑的模式，适合小型项目。\n敏捷方法介于无软件开发和传统软件开发方法之间；将更重要的注意力集中于可运行的代码本身，而不太重视各类文档、流程之类的。\n价值观与最佳实践\n敏捷开发下的模型\nSCRUM\n例题 学霸肯定对了 ↕ C 学霸肯定对了 ↕ B A 学霸肯定对了 ↕ B 学霸肯定对了 ↕ B D "},{"id":35,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/3-%E5%87%80%E5%AE%A4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","title":"3) 净室软件工程与逆向工程","section":"3.9 软件工程","content":" 净室软件工程与逆向工程 ✌ # 1 净室软件工程 # 2 逆向工程 # 山寨，比如说军事领域的航母。\n软件逆向工程就是分析已有的程序，寻求比源代码更高级的抽象表现形式。在逆向工程导出信息的四个抽象层次中， 结构级包括反映程序各部分之间相互依赖关系的信息; 功能级包括反映程序段功能及程序段之间关系的信息。\n例题 学霸肯定对了 ↕ B C "},{"id":36,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/4-%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/","title":"4) 需求工程","section":"3.9 软件工程","content":" 需求工程 ✌ # 1 概述 # 软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望。\n软件需求是指用户解决问题或达到目标所需的条件或能力，是系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明。\n需求工程包括两个维度：需求开发维度(技术维度)和需求管理维度(管理维度)。\n需求定义的产出是：需求规格说明书SRS。\n需要验证的产出是需求基线，需求管理的对象就是需求基线。\n例题 学霸肯定对了 ↕ D 2 需求获取 # 从技术维度分：\n需求分为：业务需求(整体全局)、用户需求(用户视角)、系统需求(计算机化)。\n系统需求分为：功能需求、性能需求、设计约束需求(既不是功能需求、又不是性能需求的就属于设计约束需求)。\n从管理维度分：\n需求分为：基本需求、期望需求(比较难把握，客户觉得你应该做的)、兴奋需求。\n3 需求分析 # 需求分析包含两个方面：\n1、结构化需求分析SA；\n2、面向对象需求分析OOA。\n4.3.1 结构化需求分析SA # SA要求完成功能模型(数据流图DFD，也叫分层数据流图)、行为模型(状态转换图STD)、数据模型(ER图)，其中数据字典起到解释的作用(学生：学号、名字、年龄)，比如学生关系包含学号、名字、年龄等。\nDFD：Data Flow Diagram，（功能建模）系统跟外界实体之间的交互，数据、加工交换的方式。\nSTD：State Transform Diagram，（状态建模）\nE-R图：实体关系图，（数据建模）\n例题 学霸肯定对了 ↕ C D\n用例图、对象图、通信图、顺序图和活动图都是面向对象的图，都是UML里面的图\n4.3.2 面向对象需求分析OOA # 面向对象的相关概念。\n类的考察方法：\n实体类：永久保存某些数据。\n边界类：人机交互界面、系统交互接口之类的。\n实体类：非实体类和边界类就是实体类。\n1）UML # UML全称Unified Modeling Language，统一建模语言，UML由构造块、规则和公共机制；构造块中最重要的是事物和图；事物中包含结构事物是静态部分、行为事物是动态部分。\nUML图同事物一样，也分为静态部分和动态部分，静态图称为结构图，动态图为行为图。得知道每种图大致是什么意思(标红的为重点)。\nUML4+1视图，同架构的4+1视图可以一一对应\n一般UML分析阶段建模主要是建立用例模型(用例图)和分析模型(类图)\n4 需求定义 # 把需求分析的成果落地成文档的过程就是需求定义的过程。需求定义包含2大类：严格定义法、原型法。\n需求定义的产物的是：需求规格说明书SRS。\n例题 学霸肯定对了 ↕ C 5 需求验证 # 对需求规格说明书SRS进行验证，需求甲方参与确认。最为最终的需求基线。\n6 需求状态管理 # 又称为需求管理，一个需求确认以后，往往会有多个状态的变迁。\n7 需求跟踪 # 需求工程的目标是获取用户最真实的需求，可往往在开发测试过程中会出现遗漏，这时候需要及时跟踪需求，以发现纰漏。\n用户的需求称为原始需求，软件需求可以认为是用例(功能)，UC-n没有打钩，表示这个功能多余了，用户其实不需要这个功能；FR-m没有打钩，表示这个功能漏做了。\n8 需求变更 # 变更是每个项目中客观存在的。无法杜绝的。我们要做的是控制好需求变更的管理。\n例题 学霸肯定对了 ↕ D B "},{"id":37,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/5-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/","title":"5) 软件系统建模","section":"3.9 软件工程","content":" 软件系统建模 # 1 软件系统建模 # 在论文里面考过，通过图示可以看见，物理模型对应于软件设计，逻辑模型对应于需求分析，所以里面可以写的点还是挺多的。\n这跟逆向工程有点像，先分析现有系统，根据现有系统得到新系统的过程。\n例题 学霸肯定对了 ↕ "},{"id":38,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/6-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","title":"6) 系统设计","section":"3.9 软件工程","content":" 系统设计 # 1 界面设计 # 例题 学霸肯定对了 ↕ A 2 软件设计 # 体系结构设计就是架构设计。\n例题 学霸肯定对了 ↕ B A D 6.2.1 结构化设计 # 外部和内部、高内聚和低耦合的角度都是模块，符合自顶向下的原则。扇入：别人调自己，扇出：自己调别人。\n6.2.2 面向对象设计 # 面向对象设计的上一步是面向对象分析OOA；它所包含的总体任务如下：\n面向对象的设计原则如下： 例题 学霸肯定对了 ↕ C 设计模式 设计模式-github代码\n设计模式属于面向对象设计里面的一个点，详情见 6.3 设计模式\n6.3 设计模式 # 学习设计模式需要关注的点：\n1、设计模式三种类型的定位\n2、设计模式的分类\n3、设计模式应用场景及特点\n设计模式的三种类型 例题 学霸肯定对了 ↕ A B B 设计模式的分类 创建型模式：创建对象(目标) 结构型模式：更大的结构(目标) 行为型模式：交互及指责分配(目标) 类模式（类似于类的静态方法，不用初始化对象，直接通过类名来调用）\n6.3.1 创建型模式 # 工厂方法模式 抽象工厂模式 构建器模式 原型模式 对象的直接克隆。\n单例模式 例如数据库的连接。\n6.3.2 结构型模式 # 适配器模式 桥接模式 组合模式 代理模式 应用程序的快捷方式。房东房子很多，需要卖房的时候，他把房子全权代理给房屋代理机构，让该机构负责。注意跟中介模式、适配器模式区分。\n装饰模式 动态的附加一些简单的职能。原始的咖啡加糖，加冰等等。\n外观模式 子系统的一组接口对外提供一个统一的接口。比如说：一键开会(拉下幕布，打开投影仪，灯光降低，关闭窗帘)。\n享元模式 汉字编码。常用汉字也就几千字，如果在word中有几十万字，那么大多数都是重复的常用汉字，那么这些常用汉字可以共享空间。\n6.3.3 行为型模式 # 中介模式 解决买房和卖房信息不对称的矛盾，两个对象之间的两两交互过于麻烦，简化流程。比如银联、央行。\n职责链模式 提交的请假如果本层解决不了，则层层网上传递，这就形成一个职责链。跟某些部门踢皮球一样。\n命令模式 日志记录，可撤销。将命令封装在对象里面，如word的各种撤销(及时性的东西)等等。\n解释器模式 如架构风格里面的虚拟机风格。可为特定的、自定义的场景做出解释，如迷宫。\n迭代器模式 若高级语言里面的可迭代对象。数据集的某些迭代操作。\n备忘录模式 快照。可以在不向外界公开具体细节的时候恢复到最初的状态，游戏存档，git版本存档。命令模式是撤销一些及时性的东西。\n观察者模式 订阅、广播、联动。在Execl中，A1=10,A2=20,A3=A1+A2，当A1或A2变化时A3也会随之变化。\n状态模式 将状态变成类，可以很好地管理状态之间的变迁。不同的状态对应不同的行为和属性。订酒店：房间有空闲状态，入住状态，待清洁状态等等。会员的升级等。\n策略模式 多方案、多策略的切换。如商场打折。\n模板方法模式 PPT模板、简历模板等。如软件开发里面的框架。\n访问者模式 数据与操作分离。因为操作老是会变，而数据基本不变。将变的和不变的分离开来。\n例题 学霸肯定对了 ↕ A D C B "},{"id":39,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/7-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95/","title":"7) 软件测试与调试","section":"3.9 软件工程","content":" 软件测试与调试 # 1 软件测试方法 # 测试的原则 尽早、不断的进行测试 程序员避免测试自己设计的程序 既要选择有效、合理的数据，也要选择无效、不合理的数据 修改后应进行回归测试 尚未发现的错误数量与该程序已发现错误数成正比 1.1 测试类型的划分 # 结构化测试。\n等价类划分：各个阶段的测试用例各选一个，如1-1000分为普卡用户，1001-3000为金卡用户，大于等于3001为砖石卡。\n例题 学霸肯定对了 ↕ A C 1.2 测试阶段 # 结构化测试。\n集成测试 系统测试 例题 学霸肯定对了 ↕ A 学霸肯定对了 ↕ A D 1.3 面向对象测试 # 和结构化测试基本上一一对应，只需要了解每个层大概有什么测试方法就行，不用掌握每一种方法。\n2 软件调试 # 2.1 软件调试方法 # 原因排除法：正向找错，回溯法：反向找错。\n2.2 调试和测试的区别 # "},{"id":40,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/8-%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E4%B8%8E%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4/","title":"8) 系统运行与软件维护","section":"3.9 软件工程","content":" 系统运行与维护 # 1 遗留系统的处置问题 # 功能模型DFD和数据模型ER是需求分析的产物。\n例题 学霸肯定对了 ↕ D 2 新旧系统的转换策略 # 3 数据转换与迁移 # "},{"id":41,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/9-%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/","title":"9) 专项练习","section":"3.9 软件工程","content":" 专项练习，讲义222页 # "},{"id":42,"href":"/docs/example/hidden/","title":"Hidden","section":"介绍","content":" This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); } Fronde cetera dextrae sequens pennis voce muneris # Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "},{"id":43,"href":"/docs/example/leetcode/1-hot100/","title":"1) Hot100","section":"5. leetcode","content":" hot100 # "}]