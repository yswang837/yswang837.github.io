[{"id":0,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/1-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A6%82%E8%BF%B0/","title":"1) 软件架构的概述","section":"3.10 软件架构设计","content":" 1.软件架构的概述🏁 # 1.1 软件架构的概念 # 软件架构即软件体系结构，软件架构设计就是需求的分配，即将满足需求的职责分配到组件上。它搭建起了需求分析与软件设计之间的鸿沟。如下图： 架构的本质\n1. 软件架构为软件系统提供了一个结构、行为和属性的高级抽象。\n2. 软件架构风格是特定应用领域的管用模式，架构定义了一个词汇表和一组约束。 架构的作用\n1. 软件架构是项目干系人进行交流的手段。\n2. 软件架构是可传递和可复用的模型。\n3. 软件架构使推理和控制的更改更加简单，有助于循序渐进的原型设计。 例题 学霸肯定对了 ↕ D 1.2 软件架构的发展 # 软件架构的发展经历了无架构模式(汇编语言)、萌芽阶段(程序结构设计)、初级阶段(统一建模语言UML)、高级阶段(4+1视图)。\n4+1视图如下： 。\n例题 学霸肯定对了 ↕ A D C 习题 # "},{"id":1,"href":"/docs/example/architect-exam/3.1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","title":"3.1 计算机组成与体系结构","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 ✌ # 计算机结构 ✅ 存储系统 ✅✅✅✅ 数据传输控制方式 ✅ 总线 ✅✅ CISC与RISC ✅ 流水线 ✅✅ 校验码 ✅ 嵌入式 ✅ 1 计算机结构 # 计算机的硬件包含5大组成：控制器、运算器、存储器、输入设备和输出设备。CPU依据指令周期的不同阶段来区分二进制的指令和数据，因为在指令周期的不同阶段指令会命令CPU分别去取指令或者数据。程序员是可以通过汇编语言直接操作CPU中的寄存器的。\n冯诺依曼：一般用于pc处理器，指令和数据存储在一起、指令和数据都是通过相同的数据总线传输，通过不同的周期来区分数据和指令。\n哈佛结构：一般用于嵌入式系统处理器DSP(数字信号处理器)，指令和数据可并行分开存储与传输。\n它们之间的交互如下图： 别的部件会在后面的章节详细讲解，这里只说运算器和控制器。\n1.1 运算器 # 算术逻辑单元ALU：实现对数据的算术和逻辑运算。\n累加寄存器AC：通用寄存器、运算结果或源操作数的存放区。\n数据缓冲寄存器DR：暂时存放内存的指令或数据。\n状态条件寄存器PSW：保存指令运行结果的条件码内容，如溢出标志、进位等。\n1.2 控制器 # 程序计数器PC：存储下一条要执行指令的地址。\n指令寄存器IR：存储即将执行的指令。\n指令译码器ID：对指令中的操作码字段进行分析解释。\n时序部件：提供时序控制信号。\n例题 学霸肯定对了 ↕ 答案：A\n计算机执行程序时，在一个指令周期的过程中，为了能够从内存中读指令操作码，首先是将程序计数器(PC)的内容送到地址总线上，PC-\u0026gt;IR。 学霸肯定对了 ↕ 答案：B 2 存储系统 # 整体采用分层的思想，主要是解决速度、容量和成本之间的矛盾。内存外存称为虚拟存储器、cache内存外存成为三级存储结构.如下图： 2.1 Cache # 高速缓存Cache用来存储当前最活跃的程序和数据，直接与CPU交互，位于CPU和主存之间,容量小，速度为内存的5-10倍，其内容是主存(内存)的拷贝，对于程序员来说是透明的。Cache由控制部分和存储器组成，存储器存储数据，控制部分判断CPU要访问的数据是否在Cache中，在则命中不在则依据一定的算法从主存中替换。\n地址映射：在CPU工作时，送出的是主存单元的地址，而应从Cache存储器中读/写信息。这就需要将主存地址转换为Cache存储器地址，这种地址的转换称为地址映像，由硬件自动完成映射。\nCache的功能：\n1.提高CPU数据输入输出的速率，突破冯·诺依曼瓶颈，即突破CPU与存储系统间数据传送带宽限制。\n2.在计算机的存储系统体系中(除cpu中的寄存器外)，Cache是访问速度最快的层次。\n3.Cache对程序员来说是透明的。\n4.使用Cache改善系统性能的依据是程序的局部性原理(总的来说，在CPU运行时，所访问的数据会趋向于一个较小的局部时空内。包括下面两个方面: 时间局部性原理:如果一个数据项正在被访问，那么在近期它很可能会被再次访问(代码里面的循环)，即在相邻的时间里会访问同一个数据项。空间局部性原理:在最近的将来会用到的数据的地址和现在正在访问的数据地址很可能是相近的，即相邻的空间地址会被连续访问(数组))\nCache的命中率：\n当CPU所访问的数据在Cache中时，命中，直接丛Cache中读取数据，设读取一次Cache时间为1ns，若CPU访问的数据不在Cache中，则需要从内存中读取，设读取一次内存的时间为1000ns，若在CPU多次读取数据过程中，有90%命中Cache(90%一般由cache的算法决定)，则CPU读取一次的平均时间为(90% * 1 + 10% * 1000)ns。\n例题 学霸肯定对了 ↕ B 学霸肯定对了 ↕ D 学霸肯定对了 ↕ A 2.2 主存(内存)编址计算 # 主存如图所示，可以看图试着回答红色框线里面的问题，图中一个存储单元存放了4个bit位，每个存储单元的地址就是我们熟悉的指针，看完应该知道32位机器和64位机器大概是啥意思了。 特别提醒：不要硬算，要化简为二进制或者十进制来算。\n存储单元个数=最大地址-最小地址+1\n编址方式 按字编址：一个存储单元存储的是一个字，最小寻址单位是一个字。 按字节编址：一个存储单元存储的是一个字节，最小寻址单位是一个字节。 总容量=存储单元个数*单个存储单元所占大小\n单位换算：1GB=1024MB，1MB=1024KB，1KB=1024Byte，1Byte=8bit。K=2^10，M=2^20，G=2^30\n例题 学霸肯定对了 ↕ 答案：B C\n总容量=BFFFFH+1-80000H=40000H，转换为十进制为：4 * 16^4=262144，因为按字节编址，所以总容量为262144字节，即262144/1024=256KB，16k * 4bit = 8k * 8bit(1字节=8bit)，所以用这种芯片存这些数据，所需的芯片数量为：256/8=32片 2.3 磁盘管理 # todo 视频20-磁盘管理-磁盘移臂调度算法\n磁盘有正反两个盘面，每个盘面有多个同心圆，每个同心圆是一个磁道，每个同心圆又cd被划分为多个扇区，数据就被存放在一个个扇区中。\n磁头首先要寻找到对应的磁道，然后等待磁盘进行周期旋转，旋转到指定的扇区，才能读取到对应的数据，因此，会产生寻道时间和等待时间和存取数据的时间。其公式为：存取时间=寻道时间+等待时间+存取数据时间(在考试时，有这个时间就算上，没有就忽略)\n磁盘调度算法(磁盘旋转是同方向匀速旋转，只会在寻道的时候产生优化算法) 先来先服务FCFS:根据进程请求访问磁盘的先后顺序进行调度。 最短寻道时间优先SSTF:请求访问的磁道与当前磁道最进的进程优先调度，使得每次的寻道时间最短。会产生“饥饿”现象，即远处进程可能永远无法访问。 扫描算法SCAN:又称“电梯算法”，磁头在磁盘上双向移动，其会选择离磁头当前所在磁道最近的请求访问的磁道，并且与磁头移动方向一致，磁头永远都是从里向外或者从外向里一直移动完才掉头。 单向扫描调度算法CSCAN: 与电梯算法类似，与SCAN不同的是，其只做单向移动，即只能从里向外或者从外向里。 例题 学霸肯定对了 ↕ 答案：D 学霸肯定对了 ↕ 答案：D\n读取一个块需要的时间：10*10ms(移动)+100ms(延迟)+2ms(传输)=202ms，读取100个块需要的时间：100ms * 202ms = 20200ms 例题 学霸肯定对了 ↕ 答案：C B\n由题意可知每个扇区存放逻辑记录，处理单个记录的延时为：33/11+3=6ms，由于磁头处于r0的开始处，且是单缓冲区（同一时间只能一个任务读或者写缓冲区）顺序处理这些记录，所以6+10*(33+3)=366；若对存储信息进行优化，优化后为：r0r6r1r7r2r8r3r9r4r10r5，r0和r5收尾相接形成一个完整的磁道。此时只需要转2圈就可以把数据处理完。 磁盘单缓冲区与双缓冲区的读取问题 学霸肯定对了 ↕ 答案：D C\n也可用流水线的公式计算，详见流水线例题 3 数据传输控制方式 # 主存和外设交换数据\n3.1 程序查询方式 # 程序控制(查询)方式:CPU主动查询外设是否完成数据传输，效率极低。\n3.2 程序中断方式 # 程序中断方式: 外设完成数据传输后，向CPU发送中断，等待CPU处理数据，效率相对较高，中断响应时间指的是从发出中断请求到开始进入中断处理程序;中断处理时间指的是从中断处理开始到中断处理结束。中断向量提供中断服务程序的入口地址。多级中断嵌套，使用堆栈来保护断点和现场。如鼠标键盘\n3.3 DMA方式 # DMA方式(直接主存存取):CPU只需完成必要的初始化等操作，数据传输的整个过程都中，都由DMA控制器来完成，在主存和外设之间建立直接的数据通路，效率很高。如硬盘\n例题 学霸肯定对了 ↕ 答案：D C 学霸肯定对了 ↕ 答案：D 4 总线 # 总线(Bus)，是指计算机设备和设备之间传输信息的公共数据通道。总线是连接计算机硬件系统内多种设备的通信线路，它的一个重要特征是由总线上的所有设备共享，因此可以将计算机系统内的多种设备连接到总线上。一条总线同一时刻仅允许一个设备发送，但允许多个设备接收，所以总线是半双工模式。\n总线具体分为数据总线(并行数据传输位数)、地址总线(系统可管理的内存空间的大小) 、控制总线(传送控制命令)。\n例题 学霸肯定对了 ↕ 答案：B 学霸肯定对了 ↕ 答案：C 5 CISC与RISC # 6 流水线 # 流水线时间计算\n流水线周期:指令分成不同执行段(取址、分析、执行)，其中执行时间最长的段为流水线周期。\n流水线执行时间:1条指令总执行时间+ (总指令条数-1)*流水线周期。\n流水线吞吐率计算:吞叶率即单位时间内执行的指今条数。即：指令条数/流水线执行时间\n流水线的加速比计算:加速比即使用流水线后的效率提升度，即比不使用流水线快了多少倍，越高表明流水线效率越高。即：不使用流水线执行时间/使用流水线执行时间。\n例题 学霸肯定对了 ↕ 答案：D C B C\n解析：设每个盘块儿读入缓冲区的时间为t1、缓冲区送入用户区的时间为t2、用户区处理每个盘块儿的时间为t3，为了能够代入流水线执行时间的公式，需要将题目转成标准的流水线。\n对于单缓冲区而言，需要将3阶段流水线转换成2阶段流水线，即第一阶段为t1+t2，第二阶段为t3，所以：流水线执行时间=1条指令总执行时间+ (总指令条数-1)*流水线周期 = (t1+t2)+t3 + (10-1) * 20 = 201\n对于双缓冲区而言，题目已经是标准流水线了，可以直接带入公式，所以：流水线执行时间=1条指令总执行时间+ (总指令条数-1)*流水线周期 = t1+t2+t3 + (10 - 1) * 15 = 156\n流水线的吞吐率，由题目可知，已是标准流水线，可直接带入公式算吞吐率，设执行了N条指令，n/9t+(n-1)3t，即(n/(3n+6)) * (1/t)，当n趋于无穷大时，得到最大吞吐率为1/3t\n流水线的加速比=不使用流水线执行时间/使用流水线执行时间，不使用流水线执行时间=10(2+1+3+1+2)=90，使用流水线执行时间=9+(10-1)*3=36，即90/36=5/2 7 校验码 # 7.1 奇偶校验码 # 奇偶校验码:在编码中增加1位校验位来使编码中1的个数为奇数(奇校验)或者偶数(偶校验)，编码中，含有奇数个1，发送给接收方，接收方收到后，会计算收到的编码有多少个1，如果是奇数个，则无误，是偶数个，则有误。\n7.2 循环冗余码 # 例题 学霸肯定对了 ↕ 答案：A\n解析：补零：原始信息串为1100，生成多项式为3阶，则补3个0，即被除数为：1100000，除数也是根据生成多项式来的，幂指数存在的为1，不存在的为0，即1011(题目已经给出了，未给出的时候要知道是这样算的)，异或相除将余数010(不足3位的在左边补0)添加到原始信息串1100后面得到1100010，即选A 7.3 海明码 # 例题 学霸肯定对了 ↕ 答案：D B\n解析：32 16 8 4 2 1 需要6位。读题目可知D5是第10位，用8+2校验，故选B 8 嵌入式 # 嵌入式系统的初始化过程：片级初始化-\u0026gt;版级初始化-\u0026gt;系统初始化 例题 学霸肯定对了 ↕ A 学霸肯定对了 ↕ A 章节习题 # 第10题 # 第20题 # 第30题 # 前沿题 # "},{"id":2,"href":"/docs/example/","title":"介绍","section":"Docs","content":" 关于博客 # 这个博客是我个人开设的第二个博客，主要用于记录作者在计算机行业摸爬滚打10余年的经历、各类资料干货以及学习心得等，持续更新中\u0026hellip;\u0026hellip;\n本项目的所有的免费资源均挂载在github，地址为：https://github.com/yswang837/yswang837.github.io，同时欢迎热爱开源的朋友fork下来，提交给我你的代码，让我们一起完善这个项目吧；如果你认为本博客帮助了你，欢迎star。\n请你在阅读本站内容时，时刻持有一种质疑的态度，这样不仅能够帮助自己思考，也能发现我文章的不足之处；文章中难免引用到来自网络的各类资料，如果你觉得侵犯了你的版权，请联系我，我将立即删除；如果文章中有什么错漏的地方请大家见谅，也欢迎大家随时加我微信wys837帮我指正，希望与大家一起进步。感谢！\n关于作者 # 笔名：小钻风\n微信：wys837\ngithub: https://github.com/yswang837\n"},{"id":3,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/2-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/","title":"2) 软件架构风格","section":"3.10 软件架构设计","content":" 2.软件架构风格🏁 # 架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个构件有效地组织成一个完整的系统。架构风格定义了用于描述系统的术语表和一组指导构建系统的规则。以下是常见风格的特点或应用：\n批处理\u0026mdash;\u0026gt;传统编译器。\n管道过滤器\u0026mdash;\u0026gt;支持分阶段数据处理。\n层次架构\u0026mdash;\u0026gt;采用层次化架构风格的系统，划分的层次越多，系统性能越差。\n过程控制\u0026mdash;\u0026gt;控制系统，其特点是不断采集系统当前状态，与系统中的设定状态进行对比，并通过将当前状态与设定状态进行对比从而进行控制。\n隐式调用\u0026mdash;\u0026gt;回调机制，采用隐式调用架构风格的系统，可以通过处理函数的并发调用提高系统处理性能。\n事件系统\u0026mdash;\u0026gt;注册事件处理的是回调函数，当某个界面事件发生时（例如键盘敲击、鼠标移动等)，系统会查找并选择合适的回调函数处理该事件。\n解析器\u0026mdash;\u0026gt;运行时的系统行为定义与改变的能力，采用解释器架构风格的系统，可以通过部分解释代码预先编译的方式提高系统性能。\n黑板风格\u0026mdash;\u0026gt;信号处理领域，语音识别系统是一个十分典型的专家系统，其特点是求解的正确结果不止一个，求解过程比较复杂，需要通过专家知识和反馈逐步得到正确结果。\n虚拟机风格\u0026mdash;\u0026gt;通过虚拟机架构屏蔽不同的硬件环境。\nC2体系结构风格\u0026mdash;\u0026gt;通过连接件绑定在一起的按照一组规则运作的并行构件网络。\n数据仓库\u0026mdash;\u0026gt;现代集成开发环境（现代编译器）。\n下图是架构师考试中常见的架构风格及其子风格，接下来会详细介绍每一种风格。 2.1 数据流风格 # 数据流风格以数据驱动的方式推进项目，其的典型应用有传统编译器、网络报文处理，它包含2个子风格：\n1、批处理。做题要点：大量整体数据、无需用户交互\n2、管道过滤器。做题要点：流式数据、弱用户交互\n具体如下图： 2.2 调用/返回风格 # 调用/返回风格包含3个子风格：\n1、主程序/子程序风格\n2、面向对象风格\n3、分层风格，将在“2.8 架构风格具体实例”中详细说明\n2.3 独立构建风格 # 独立构建区别于返回/调用风格的点在于，相对松耦合，且放弃了对子程序的控制，它包含2个子风格：\n1、进程通信\n2、事件驱动系统（隐式调用）\n2.4 虚拟机风格 # 虚拟机风格包含2个子风格：\n1、解释器风格，做题关键字：需要自定义规则的场景\n2、规则系统，做题关键字：在解释器的基础上增加经验规则\n2.5 仓库风格 # 仓库风格包含2个子风格：\n1、数据库系统\n2、黑板系统 2.6 闭环控制风格(过程风格) # 2.7 C2架构风格 # \\\n例题 学霸肯定对了 ↕ 1.虚拟机 2.数据流 3.独立构建风格 4.解释器 5.过程控制 学霸肯定对了 ↕ 1.黑板 2.隐式调用 3.事件驱动风格 学霸肯定对了 ↕ 1.顺序批处理 2.数据共享 3.隐式调用风格 4.模拟 5.虚拟机 2.8 架构风格具体实例 # 没有最好的架构，只有更适合具体业务场景的架构。\n2.8.1 从 C/S -\u0026gt; B/S -\u0026gt; 混合架构 # 双层C/S架构\n通过图示可以看出非常明显的缺点：将业务逻辑的代码嵌入进客户端，在早期互联网并不普及的情况下，频繁变更的业务逻辑代码和难以推广升级的客户端存在巨大矛盾。 三层C/S架构\n相比于双层C/S架构，三层C/S架构的优势在于：将业务逻辑层单独拆分出来(独立于数据库服务器、用户客户端)放在单独的服务器上，经常变更的业务逻辑代码并不会直接影响到客户端的使用。其劣势依然需要用户安装客户端(你可以认为就是手机中的APP)。 B/S架构\n相比于C/S架构，B/S架构也有自己的优缺点\n优势：推广容易，不需要用户下载什么客户端之类的，只需要浏览器访问对应地址即可，这也就是早期各大厂都是从门户网站起家的。\n劣势：响应速度较慢，早期只能整个提交页面数据(不能局部刷新)、其安全性较低等。 混合架构\n结合了C/S和B/S的优势，左图适用于企业内部的软件，对系统的维护有优势；右图适用于主流互联网公司的架构，查询用B/S、修改用C/S架构。 2.8.2 MVC架构风格 # MVC(Model-View-Controller)，Model(模型) 是应用程序中用于处理应用程序数据逻辑的部分，通常模型对象负责在数 据库中存取数据。View(视图) 是应用程序中处理数据显示的部分，通常视图是依据模型数据创建的。Controller(控制器)是应用程序中处理用户交互的部分，通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。\nMVC分为主动MVC和被动MVC(具体不用了解)，MVC架构的缺点在于MV之间没有解耦，不是严格的分层架构(严格的分层架构：当前层之和上下层之间有联系) 在J2EE中（java相关的框架在考试中经常被拿来举例子，因此会java的很有优势），Model是Entity Bean/Session Bean，View是JSP，Controller是Servlet。\n2.8.3 MVP架构风格 # MVP(Model-View-Presenter)，注意：它不是LOL中的MVP，它是MVC的变种，它实现了MV之间的解耦。 2.8.4 MVVM架构风格 # MVVM(Model-ViewModel-View),类似于vue中的双向数据绑定，View改变则ViewModel也改变，反之亦然。 2.8.5 RIA架构风格 # RIA(富互联网架构)类似于综合了C/S和B/S架构的优点(C/S反应快，交互强，B/S易传播)，它在首次加载初期比较慢，一旦加载完成使用就快多了。典型的例子就是在线网游。\n2.8.6 基于服务的架构(SOA) # 1、服务构件粗粒度，传统构件细粒度居多。\n2、服务构件的接口是标准的，主要是WSDL接口，传统构件常以具体API形式出现。\n3、服务构件的实现与语言无关，传统构件绑定某种特定语言。\n4、服务构件可以通过构件容器提供OoS的服务，传统构件完全由程序代码直接控制。 SOA的实现方式：WebService；WSDL就是WebService接口对应的WSDL文件，该文件通过xml格式说明如何调用可以看作WebService的接口文档 (使用说明书)。 SOA的实现方式：ESB 2.8.7 微服务 # 微服务顾名思义，就是很小的服务，所以它属于面向服务架构的一种。 微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通 (通常是基于HTTP协议的RESTfulAPI)。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。\n其特点有：\n1、小,且专注于做一件事情。\n2、轻量级的通信机制。\n3、松耦合、独立部署。\n微服务的优势：\n1、技术异构\n2、弹性扩展\n3、在自动化部署情况下，能简化部署\n4、可组织性\n微服务的挑战：\n1、分布式系统的复杂度\n2、运维成本\n3、服务间的依赖管理和测试\n4、部署自动化\\\nSOA与微服务的对比 2.8.8 MDA # 习题 # 第1题 # 第10题 # 第20题 # 第30题 # 第40题 # 第50题 # 第60题 # 第70题 # "},{"id":4,"href":"/docs/example/architect-exam/3.2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"3.2 操作系统","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 操作系统的组成及作用 ✅✅✅ 操作系统的特性 ✅✅✅ 操作系统的分类 ✅✅✅ 进程管理 进程的状态 ✅✅✅ 前趋图 ✅✅✅✅ 信号量与P/V操作 ✅✅✅✅ 死锁及银行家算法 ✅ 存储管理 页式存储 ✅✅✅ 段式存储 ✅✅✅ 页面置换算法 ✅ 文件管理 绝对路径与相对路径 ✅ 索引文件 ✅✅✅ 位示图 ✅ 设备管理 ✅✅ 1 操作系统的组成及作用 # 案例分析易考。\n1.1 操作系统的组成 # 通常由操作系统内核 (Kernel) 和其他许多附加的配套软件所组成，包括图形用户界面程序、为支持应用软件开发和运行的各种软件构件(如应用框架、编译器和程序库等)、常用的应用程序(如任务管理器、防火墙、网络浏览器等)。\n其中，内核指的是能提供进程管理(任务管理)、存储管理、文件管理和设备管理等功能的那些软件模块，它们是操作系统中最基本的部分，用于为众多应用程序访问计算机硬件提供服务。由于应用程序直接对硬件操作非常复杂，所以操作系统内核对硬件设备进行了抽象，为应用软件提供了一套简洁、统一的接口(称为系统调用接口或应用程序接口 API)。内核通常都驻留在内存中，它以 CPU 的最高优先级运行，能执行指令系统中的特权指令，具有直接访问各种外设和全部主存空间的特权，负责对系统资源进行管理和分配。\n1.2 操作系统的作用 # 操作系统主要有以下 3 个方面的重要作用：\n(1) 管理计算机中运行的程序和分配各种软硬件资源。计算机中一般总有多个程序在运行.这些程序在运行时都可能要求使用系统中的资源(如访问硬盘，在屏幕上显示信息等)，此时操作系统就承担着资源的调度和分配任务，以避免冲突，保证程序正常有序地运行。操作系统的资源管理功能主要包括处理器管理、存储管理、文件管理、I/O 设备管理等几个方面。\n(2) 为用户提供友善的人机界面。人机界面的任务是实现用户与计算机之间的通信(对话)。几乎所有操作系统都向用户提供图形用户界面 (GUI)。\n(3) 为应用程序的开发和运行提供一个高效率的平台。操作系统屏蔽了几乎所有物理设备的技术细节，它以规范、高效的方式 (例如系统调用、库函数等)向应用程序提供了有力的支持，从而为开发和运行其他系统软件及各种应用软件提供了一个平台。\n2 操作系统的特性 # 案例分析易考。\n2.1 并发性 # 在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序同时运行，但实际上在单CPU的运行环境，每一个时刻只有一个程序在执行。因此，从微观上来说，各个程序是交替、轮流执行的，如果计算机系统中有多个 CPU，则可将多个程序分配到不同 CPU 上实现并行运行。\n2.2 共享性 # 共享是指操作系统中的资源(包括硬件资源和信息资源)可以被多个并发执行的进程(线程)共同使用，而不是被一个进程所独占。\n2.3 不确定性 # 但由于资源有限，在多数情况下进程的执行不是一贯到底的，而是“走走停停”。例如一个进程，在 CPU上运行一段时间后，由于等待资源或某事件发生，它被暂停执行，将 CPU 转让给另一个进程执行。系统中的进程何时执行，何时暂停，以什么样的速度向前推进，进程总共要花多少时间执行才能完成，这些都是不可预知的。\n3 操作系统的分类 # 案例分析易考。\n3.1 批处理操作系统 # 单道批处理系统 单道批处理操作系统是一种早期的操作系统，用户可以向系统提交多个作业，“单道”的含义是指一次只有一个作业装入内存执行。作业由用户程序、数据和作业说明书(作业控制语言)3个部分组成。当一个作业运行结束后，随即自动调入同批的下一个作业，从而节省了作业之间的人工干预时间，提高了资源的利用率。 多道批处理操作系统 允许多个作业装入内存执行，在任意一个时刻，作业都处于开始点和终止点之间。每当运行中的一个作业由于输入/输出操作需要调用外部设备时，就把 CPU 交给另一个等待运行的作业，从而将主机与外部设备的工作由串行改变为并行，进一步避免了因主机等待外设完成任务而浪费宝贵的 CPU 时间。多道批处理系统主要有3 个特点:多道、宏观上并行运行和微观上串行运行。 3.2 分时操作系统 # 在分时操作系统中，一个计算机系统与多个终端设备连接。分时操作系统是将 CPU 的工作时间划分为许多很短的时间片，轮流为各个终端的用户服务。例如，一个带 20 个终端的分时系统，若每个用户每次分配一个 50ms 的时间片，则每隔 1s 即可为所有的用户服务一遍。因此,尽管各个终端上的作业是断续运行的，但由于操作系统每次对用户程序都能做出及时响应，因此用户感觉整个系统均归其一人占用。\n3.3 实时操作系统 # 实时是指计算机对于外来信息能够以足够快的速度进行处理，并在被控对象允许的时间范围内做出快速反应。实时系统对交互能力要求不高，但要求可靠性有保障。\n实时系统分为实时控制系统和实时信息处理系统。实时控制系统主要用于生产过程的自动控制，例如数据自动采集、武器控制、火炮自动控制、飞机自动驾驶和导弹的制导系统等。实时信息处理系统主要用于实时信息处理，例如飞机订票系统、情报检索系统等。\n3.4 网络操作系统 # 网络操作系统是使联网计算机能方便而有效地共享网络资源，为网络用户提供各种服务的软件和有关协议的集合。\n3.5 分布式操作系统 # 分布式计算机系统是由多个分散的计算机经连接而成的计算机系统，系统中的计算机无主次之分，任意两台计算机可以通过通信交换信息。通常，为分布式计算机系统配置的操作系统称为分布式操作系统。分布式操作系统能直接对系统中的各类资源进行动态分配和调度、任务划分、信息传输协调工作，并为用户提供一个统一的界面与标准的接口，用户通过这一界面实现所需要的操作和使用系统资源，使系统中若干台计算机相互协作完成共同的任务，有效地控制和协调诸任务的并行执行。分布式操作系统是网络操作系统的更高级形式，它保持网络系统所拥有的全部功能，同时又有透明性、可靠性和高性能等特性。\n3.6 微型计算机操作系统 # 微型计算机操作系统简称微机操作系统，常用的有 Windows、Mac OS、Linux。\n3.7 嵌入式操作系统 # 嵌入式操作系统运行在嵌入式智能设备环境中微型化，其主要特点如下：微型化、可定制、实时性、可靠性、易移植性\n4 进程管理 # 进程由进程控制块PCB(唯一标识)+程序(描述进程要做什么)+数据(存放进程执行所需的数据)。\n4.1 进程的三态图 # 三态图之间的状态转换就是PV操作来控制的。 例题 学霸肯定对了 ↕ A C 解析：参考进程三态图 4.2 同步互斥 # 临界资源：各进程间需要以互斥方式对其进行访问的资源。\n临界区：指进程中对临界资源实施操作的那段程序。本质是一段程序代码。\n互斥：某资源 (即临界资源)在同一时间内只能由一个任务单独使用，使用时需要加锁，使用完后解锁才能被其他任务使用，属于间接制约关系;如打印机。\n同步：多个任务可以并发执行，只不过有速度上的差异，在一定情况下停下等待，属于直接制约关系，不存在资源是否单独或共享的问题;如自行车和汽车。\n互斥信号量：对临界资源采用互斥访问，使用互斥信号量后其他进程无法访问，它是全局变量，一般用S表示，的初值为1。\n同步信号量：同步信号量:对共享资源的访问控制，初值一般是共享资源的数量，它是全局变量；一般用S表示，如公司电脑数量。 4.3 前趋图与PV操作 # P操作：申请资源，S=S-1，若S\u0026gt;=0，则执行P操作的进程继续执行;若S\u0026lt;0，则置该进程为阻塞状态 (因为无可用资源)，并将其插入阻塞队列。可认为是加锁操作。\nV操作：释放资源，S=S+1，若S\u0026gt;0，则执行V操作的进程继续执行:若S\u0026lt;=0，则从阻塞状态唤醒一个进程，并将其插入就绪队列(此时因为缺少资源被P操作阻塞的进程可以继续执行，然后执行V操作的进程继续。可认为解锁操作。\ngithub摘抄\n进程通常分为就绪、运行和阻塞三个工作状态。三个状态之间的转换就是靠PV操作来控制的。 PV操作主要就是P操作、V操作。信号量的值只能由PV操作来改变。 信号量是最早出现的用来解决进程同步与互斥问题的机制。 P表示获得，V表示释放。来源于荷兰语，P和V是荷兰语两个单词的首字母。\n信号量（Semaphore）由一个值和一个指针组成，指针指向等待该信号量的进程。信号量的值表示相应资源的使用情况。\n信号量S\u0026gt;=0时，S表示可用资源的数量。 当S\u0026lt;0时，表示已经没有可用资源，S的绝对值表示当前等待该资源的进程数。请求者必须等待其他进程释放该类资源，才能继续运行。 执行一次P操作意味着请求分配一个资源，因此S的值减1； 执行一个V操作意味着释放一个资源，因此S的值加1；此时若S\u0026lt;0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。\nS大于0那就表示有临界资源可供使用，为什么不唤醒进程？ S大于0的确表示有临界资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒。\nS小于0应该是说没有临界资源可供使用，为什么还要唤醒进程？ V原语操作的本质在于：一个进程使用完临界资源后，释放临界资源，使S加1，以通知其它的进程，这个时候如果S\u0026lt;0，表明有进程阻塞在该类资源上，因此要从阻塞队列里唤醒一个进程来“转手”该类资源。比如，有两个某类资源，四个进程A、B、C、D要用该类资源，最开始S=2，当A进入，S=1，当B进入S=0，表明该类资源刚好用完， 当C进入时S=-1，表明有一个进程被阻塞了，D进入，S=-2。当A用完该类资源时，进行V操作，S=-1，释放该类资源，因为S\u0026lt;0，表明有进程阻塞在该类资源上，于是唤醒一个。\n如果是互斥信号量的话，应该设置信号量S=1，但是当有5个进程都访问的话，最后在该信号量的链表里会有4个在等待，也是说S=-4，那么第一个进程执行了V操作使S加1，释放了资源，下一个应该能够执行，但唤醒的这个进程在执行P操作时因S\u0026lt;0，也还是执行不了，这是怎么回事呢？ 当一个进程阻塞了的时候，它已经执行过了P操作，并卡在临界区那个地方。当唤醒它时就立即进入它自己的临界区，并不需要执行P操作了，当执行完了临界区的程序后，就执行V操作。\nS的绝对值表示等待的进程数，同时又表示临界资源，这到底是怎么回事？ 当信号量S小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目.S大于0时表示可用的临界资源数。注意在不同情况下所表达的含义不一样。当等于0时，表示刚好用完。\\\n下图中的进程队列是阻塞进程队列，当S为-3时，可认为是有3个进程在等待资源。 例题 学霸肯定对了 ↕ B A\n解析：考察同步互斥，互斥信号量的初始值为1，同步信号量的初始值为 4.4 死锁 # 死锁就考死锁资源的计算。\n例题 学霸肯定对了 ↕ B\n解析：当前可用资源R1为9-7=2，R2为8-7=1，R3为5-5=0，进程P1的仍需R1资源数为6-1=5，以此类推算出所有进程的所有仍需资源数，发现首先执行P2，P2执行完成后，会释放P2的资源，即当前的发现可用资源210+211=4，2，1，即可算出是答案B 5 存储管理 # 5.1 分页存储管理 # 分页存储管理管理的是内存和外存之间的数据(同cache和内存之间的管理一样，只不过cache和内存之间靠的是硬件，而内存与外存靠的是软件（页表），这里是页式存储管理)。 页式存储管理：将用户程序(外存)与内存均划分为相同大小的块，以页为单位将程序调入内存；这样会产生一个页表的数据结构，用户程序称为逻辑页，对应于页表的页号，内存划分对应于物理块号；\n逻辑地址：页号+页内地址\n物理地址：块号(页帧号)+页内地址\n逻辑页分为页号和页内地址，页内地址就是物理偏移地址，而页号与物理块号并非按序对应的，需要查询页表，才能得知页号对应的物理块号，再用物理块号加上偏移地址才得出了真正运行时的物理地址。如果CPU查找数据时，内存中没有，就会产生缺页中断，重新去外存寻找数据。当要调用逻辑页号为3的页面到内存时，优先淘汰访问位0的页面，当多个页面的访问位为0时，才会优先淘汰修改位为0的页面。\n页面置换算法\n最优算法:0PT，理论上的算法，无法实现，是在进程执行完后进行的最佳效率计算，用来让其他算法比较差距。原理是选择未来最长时间内不被访问的页面置换，这样可以保证未来执行的都是马上要访问的。\n先进先出算法:FIFO，先调入内存的页先被置换淘汰，会产生抖动现象，即分配的页帧数越多缺页率可能越多(即效率越低)。\n最近最少使用:LRU，在最近的过去，进程执行过程中，过去最少使用的页面被置换淘汰，根据局部性原理，这种方式效率高，且不会产生抖动现象，使用大量计数器，但是没有LFU多。\n淘汰原则:优先淘汰最近未访问的，而后淘汰最近未被修改的页面。\n快表:是一块小容量的相联存储器，由快速存储器组成，按内容访问，速度快，并且可以从硬件上保证按内容并行查找，一般用来存放当前访问最频繁的少数活动页面的页号。快表是将页表存于Cache中;慢表是将页表存于内存上。慢表需要访问两次内存才能取出页，而快表是访问一次Cache和一次内存，因此更快。 例题 学霸肯定对了 ↕ C D\n页面大小为512字节，则需要用9个bit位表示；十进制的1111的二进制表示为：100 0101 0111，所以页号为二进制10，则十进制的2，查页表得知物理页4，所以选C，读题可知直接选D，因为都要共享8 例题 学霸肯定对了 ↕ A B\n页面大小为4k，得用12个bit位表示；逻辑地址=页号+页内地址，5148H的二进制的低12位都用于表示页内地址，高4位用于表示页号，所以页号就是5(0101)；物理地址=物理块号+页内地址，查页表得知块号=3，所以其物理地址的十六进制为A选项；淘汰的是在内存中，首先访问位为0的页面，即2，若多个访问位为0，则淘汰修改位为0的页面，所以选B 例题 学霸肯定对了 ↕ A C\n由程序得知矩阵是按行访问，若按行存放，则缺页中断次数=10000/200=50次，若按列存放，则缺页中断次数=10000/2=5000次 5.2 分段存储管理 # 按逻辑上的大小来截断(和页式存储不同，页式存储固定大小页面)，将进程空间分为一个个段，每段也有段号和段内地址，与页式存储不同的是，每段物理大小不同，分段是根据逻辑整体分段的，因此，段表也与页表的内容不同，页表中直接是逻辑页号对应物理块号，而下图所示，段表有段长和基址两个属性，才能确定一个逻辑段在物理段中的位置。\n学霸肯定对了 ↕ D C 6 设备管理 # 6.1 I/O软件层次 # I/O设备管理软件的所有层次及每一层功能如下图：\n实例：当用户程序试图读一个硬盘文件时，需要通过操作系统实现这一操作。与设备无关软件检查高速缓存中有无要读的数据块，若没有，则调用设备驱动程序，向1/0 硬件发出一个请求。然后，用户进程阻塞并等待磁盘操作的完成。当磁盘操作完成时，硬件产生一个中断，转入中断处理程序。中断处理程序检查中断的原因，认识到这时磁盘读取操作已经完成，于是唤醒用户进程取回从磁盘读取的信息，从而结束此次1/0 请求。用户进程在得到了所需的硬盘文件内容之，后继续运行。\n6.2 SPOOLING技术 # 虚拟性是OS的四大特性之一。如果说可以通过多道程序技术将一台物理CPU虚拟为多台逻辑CPU，从而允许多个用户共享一台主机，那么，通过SPOOling技术便可将一台物理I/O设备虚拟为多台逻辑I/O设备，同样允许多个用户共享一台物理I/O设备。\n7 文件管理 # 7.1 索引文件结构 # 如图所示，一般linux的系统中默认有13个索引节点，索引可以理解为地址、指针、盘块号，0-9为直接索引,即每个索引节点存放的是内容，假设每个物理盘大小为4KB，共可存4KB*10=40KB数据。\n10号索引节点为一级间接索引节点，大小为4KB，存放的并非直接数据，而是链接到直接物理盘块的地址，假设每个地址(指针、盘块号)占4B，则共有4KB/4B = 1024个地址，对应1024个物理盘，可存1024*4KB=4096KB数据。\n11号索引节点为二级索引节点，直接盘存放一级地址，一级地址再存放物理盘快地址，而后链接到存放数据的物理盘块，容量又扩大了一个数量级，为1024 * 1024 * 4KB数据。\n学霸肯定对了 ↕ C D\n地址大小为4Byte，磁盘索引块和磁盘数据块都是4KB大小，所以单个索引块存储了4KB/4B=256个地址，物理块一般来说在内存中是离散的，而逻辑块是连续的，所以物理块号50对应于0，67-\u0026gt;1，68-\u0026gt;2\u0026hellip;89-\u0026gt;4，58-\u0026gt;5，136的逻辑号为x-5+1=256,得到x=260，即136-\u0026gt;260，187-\u0026gt;261，所以答案选C，看题知道第二空选D 7.2 文件目录 # 相对路径：是从当前路径开始的路径。\n绝对路径：是从根目录开始的路径。\n全文件名=绝对路径+文件名。要注意，绝对路径和相对路径是不加最后的文件名的，只是单纯的路径序列。\n7.3 位示图 # 位示图是用于记录文件存储器的使用情况。每一位对应文件存储器上的一个物理块，取值 0 和 1 分别表示空闲和占用。\n学霸肯定对了 ↕ C D\n物理块号编址从0开始，所以总物理块数为16385+1=16386，16386/32=512余2，位示图编号从0开始，所以前511号编满了，512号编到第二个位置，选C，1000G*1024/4/32=8000，选D 课后习题 # 第10题 # 第20题 # 第30题 # \\\ntodo 操作系统习题\n"},{"id":5,"href":"/docs/example/architect-exam/3.3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/","title":"3.3 数据库系统","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 数据库概述 ✅✅✅ 数据库设计阶段 ✅✅ E-R模型 ✅ 关系代数 ✅✅✅✅ 规范化理论 ✅✅✅✅✅ 并发控制 ✅ 数据库完整性约束 ✅ 数据库备份与安全 ✅ 专项练习 在讲义56、296页 # "},{"id":6,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/3-%E6%9E%B6%E6%9E%84%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80/","title":"3) 架构描述语言","section":"3.10 软件架构设计","content":" 3.架构描述语言🏁 # ADL(Architect Describe Language)，它由三个基本的元素构成：\n1、构件：计算或者存储数据的单元。\n2、连接件：用于构件之间交互建模的连接块。\n3、架构配置：描述架构的构件与连接件的连接图。 学霸肯定对了 ↕ C "},{"id":7,"href":"/docs/example/architect-exam/3.4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","title":"3.4 计算机网络","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # TCP/IP协议族 DHCP与DNS ✅✅✅ TCP与UDP ✅✅✅ 网络规划与设计 逻辑设计与物理设计 ✅✅✅✅ 网络接入标准 3G与4G标准 ✅✅✅ 网络存储 ✅ 综合布线 ✅ 网络技术扩展 物联网 ✅ 云计算 ✅ "},{"id":8,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/4-%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/","title":"4) 特定领域软件架构","section":"3.10 软件架构设计","content":" 特定领域软件架构 DSSA # DSSA全称为Domain Specific Software Architecture\\\n基本活动 \\ 领域分析机制 \\ 三层次模型 \\ 例题 学霸肯定对了 ↕ "},{"id":9,"href":"/docs/example/architect-exam/3.5-%E6%95%B0%E5%AD%97%E4%B8%8E%E7%BB%8F%E6%B5%8E%E7%AE%A1%E7%90%86/","title":"3.5 数字与经济管理","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 图论 最小生成树 ✅ 最短路径 ✅ 网络与最大流量 ✅ 运筹方法 线性规划 ✅ 动态规划 ✅✅✅ 预测与决策 ✅ 数学建模 ✅✅ 1 图论 # 1.1 最小生成树 # 学霸肯定对了 ↕ 23\n解题思路：按边看，依次找最小的变长将所有节点连接起来，不能有回路，及3-6，3-7，1-2，2-6，4-7，2-5，所以长度至少为2+3+3+4+5+6=23 1.2 最短路径 # 学霸肯定对了 ↕ 81\n21+20+20+8+12=81，其他路径都比81大 1.3 网络与最大流量 # 学霸肯定对了 ↕ 23\n10+6+5+1+1=23 2 运筹方法 # 2.1 线性规划 # 学霸肯定对了 ↕ 设产品1为X，产品2位Y，立不等式，画图，最优解在顶点处，将顶点都带入目标式子，得到最值 2.2 动态规划 # 学霸肯定对了 ↕ B 2.3 预测与决策 # 学霸肯定对了 ↕ C\n解析：第一个月A=0.5，B=0.5，所以用(0.5,0.5) * 转移矩阵P，得到(0.6,0.4)，第二个月：(0.6,0.4) * 转移矩阵P=(0.64,0.36)，所以选C 学霸肯定对了 ↕ C\n解析：设8点前有A人，来：x人/分钟，检票：y人/分钟，第二问开口最少为M，A+60x=60y * 8，A+40x=40y * 10，联立得到x=4y（来一波人开4个口），带入1式，得到A=240y，A+20x=20y*M，得到M=320y/20y=16 总结：乐观-\u0026gt;大中取大，悲观-\u0026gt;小中取大，后悔值-\u0026gt;大中取小 水路代价比较小 学霸肯定对了 ↕ B 3 数学建模 # "},{"id":10,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/5-%E5%9F%BA%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/","title":"5) 基于架构的软件开发","section":"3.10 软件架构设计","content":" 基于架构的软件开发ABSD # 基于架构的软件开发ABSD(Architecture-Based Software Design)。它能很好地支持重用。\n1、ABSD方法是架构驱动，即强调由业务、质量和功能需求的组合驱动架构设计。\n2、ABSD方法有三个基础。第一个基础是功能的分解。在功能分解中，ABSD方法使用已有的基于模块的内聚和耦合技术，第二个基础是通过选择架构风格来实现质量和业务需求，第三个基础是软件模板的使用。\n3、视角与视图:从不同的视角来检查，所以会有不同的视图。\n4、用例用来捕获功能需求、特定场景用来捕获质量需求。\n4.1 开发过程 # 4.1.1 架构需求 # 4.1.2 架构设计 # 4.1.3 架构文档化 # 4.1.4 架构复审 # 架构复审的目的是标识潜在的风险，及早发现架构设计中的缺陷和错误。\n4.1.5 架构实现 # 4.1.6 架构演化 # 例题 学霸肯定对了 ↕ 学霸肯定对了 ↕ "},{"id":11,"href":"/docs/example/architect-exam/3.6-%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7/","title":"3.6 系统配置与性能评价","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 🏁 # 性能指标 ✅ 阿姆达尔解决方案 ✅✅✅ 性能评价方法 ✅✅✅ 1 性能指标 # 字长：cpu一次读取数据的长度，它也影响着最大的内存容量(最大地址)。2^32 = 4G，32位操作系统最大支持4GB内存。\n主存容量和存取速度：存取速度和cache的命中率相关。\n运算速度：主频：(单位之间内的脉冲数)2.4GHz，CPU时钟周期：1/主频。\n吞吐量和吞吐率\n响应时间\n完成时间\n兼容性\n例题 2 阿姆达尔解决方案 # 学霸肯定对了 ↕ 答案：B\n100/52 3 性能评价方法 # 课后习题 # 第10题 # 第20题 # "},{"id":12,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/6-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7/","title":"6) 软件质量属性","section":"3.10 软件架构设计","content":" 软件质量属性 # 1 性能 # 性能 (performance) 是指系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理的事件的个数。例如：\n1、同时支持1000并发；\n2、响应时间小于1ms；\n3、显示分辨率达到4k； 2 可用性 # 可用性(availability)是系统能够正常运行的时间比例。经常用两次故障之间的时间长度或在出现故障时系统能够恢复正常的速度来表示。例如：\n1、主服务器故障，一分钟内切换至备用服务器；\n2、系统故障，1小时内修复；\n3、系统支持 7 x 24 小时工作。 3 安全性 # 安全性(security)是指系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。安全性又可划分为机密性、完整性、不可否认性及可控性等特性。例如：\n1、可抵御sql注入攻击；\n2、对计算机的操作都有完整记录；\n3、用户信息数据库授权必须保证99.9%可用。 4 可修改性 # 可修改性(modifiability)是指能够快速地以较高的性能价格比对系统进行变更的能力。通常以某些具体的变更为基准，通过考察这些变更的代价衡量可修改性。例如：\n1、更改系统报表模块，2人在两周内必须完成；\n2、对Web界面风格进行修改，修改必须在2个月内完成。 例题 学霸做对了没 学霸做对了没\n基本不考的几个属性 # 可靠性、功能性、可变性、互操作性\n"},{"id":13,"href":"/docs/example/architect-exam/3.7-%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%8C%96/","title":"3.7 知识产权与标准化","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 保护范围与对象 ✅✅✅ 保护期限 ✅✅ 知识产权人确定 ✅✅✅ 侵权判定 ✅✅✅✅ 标准的分类 ✅ 标准代号的识别 ✅ 1 保护范围与对象 # 2 保护期限 # 3 知识产权人确定 # 4 侵权判定 # 5 标准的分类 # 6 标准代号的识别 # 课后习题 # "},{"id":14,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/7-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/","title":"7) 软件架构评估","section":"3.10 软件架构设计","content":" 软件架构评估 # 1. 名词解释 # 敏感点：是一个或多个构件 (和/或构件之间的关系)的特性。\n权衡点：是影响多个质量属性的特性，是多个质量属性的敏感点。\n风险点：是指架构设计中潜在的、存在问题的架构决策所带来的隐患。\n非风险点：是指不会带来隐患，一般以“xxx要求是可以实现 (或接受)的”方式表达。 2、架构评估方法 # 架构评估方法包含3中方式：基于问卷调查的方式、基于度量的方式、基于场景的方式。 2.1 基于场景的评估方法 # 基于场景的评估方法包含3种：软件架构分析法(SAAM)、架构权衡分析法(ATAM)、成本效益分析法(CBAM)。\nSAAM：最初用于分析架构可修改性，后扩展到其他质量属性。 ATAM：在SAAM的基础上发展起来的，主要针对性能、实用性、安全性和可修改性，在系统开发之前，对这些质量属性进行评价和折中。 2.2 质量效用数 # "},{"id":15,"href":"/docs/example/architect-exam/3.8-%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF%E5%8C%96%E6%88%98%E7%95%A5%E4%B8%8E%E5%AE%9E%E6%96%BD/","title":"3.8 企业信息化战略与实施","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 信息与信息化的概念 ✅ 信息系统生命周期 ✅ 信息系统战略规划 ✅✅✅ 政府信息化与电子政务 ✅ 企业信息化与电子商务 ✅✅✅ 企业门户 ✅✅ 企业应用集成 ✅✅✅ "},{"id":16,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/8-%E8%BD%AF%E4%BB%B6%E4%BA%A7%E5%93%81%E7%BA%BF/","title":"8) 软件产品线","section":"3.10 软件架构设计","content":" 软件产品线 # 1. 基本概念 # 2. 双生命周期模型 # 3. 建立方式 # 4. 组织结构 # "},{"id":17,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","title":"3.9 软件工程","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 软件开发方法 ✅✅✅ 软件开发模型 ✅✅✅✅ 净室软件/逆向工程 ✅ 需求工程 需求获取 ✅✅✅ 需求分析 ✅✅✅ UML4+1视图 ✅✅✅✅✅ UML图 ✅✅✅✅✅ UML关系 ✅✅✅✅✅ 系统设计 界面设计 ✅✅ 结构设计 ✅✅ 面向对象设计 ✅✅✅✅✅ 软件测试 软件测试方法 | 多少星不知道 软件调试 | 多少星不知道 系统运行与软件维护 系统转换计划 | 多少星不知道 软件维护 | 多少星不知道 "},{"id":18,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/9-%E6%9E%84%E5%BB%BA%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/","title":"9) 构建与中间件技术","section":"3.10 软件架构设计","content":" 构件与中间件技术 # 1. 构件的定义 # 1、软件构件是一种组装单元，它具有规范的接口规约和显式的语境依赖。软件构件可以被独立地部署并由第三方任意地组装。\n2、构件是某系统中有价值的、几乎独立的并可替换的一个部分，它在良好定义的体系结构语境内满足某清晰的功能。\n3、构件是一个独立发布的功能部分，可以通过其接口访问它的服务。 特性\n构件系统体系结构由一组平台决策、一组构件框架和构件框架之间的互操作设计组成。\n构件框架是一种专用的体系结构 (通常围绕一些关键的机制)，同时，也是一组固定地作用于构件层次机制的策略。\n概念框架的互操作设计包括系统体系结构连接的所有框架间的互操作的规则。\n构件是一组通常需要同时部署的原子构件。构件和原子构件之间的区别在于，大多数原子构件永远都不会被单独部署，尽管它们可以被单独部署。\n一个原子构件是一个模块和一组资源。\n模块是一组类和可能的非面向对象的结构体，比如过程或者函数。\n资源是一个类型化的项的固定集合。\n资源这个概念可以包含代码资源，进而包含模块。问题在干除了编译器编译一个模块或包生成的资源外，还可能存在其他的资源。在“纯对象”的方法。\n中，资源是外部化的不可改变的对象一一不可改变是因为构件没有持久化的标志，而目复制不能被区分。 2. 中间件 # 中间件是一类构件、中间件是一类系统软件 中间件技术的优点： 3. 构件的复用 # "},{"id":19,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/10-web%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","title":"10) web架构设计","section":"3.10 软件架构设计","content":" web架构设计 # "},{"id":20,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","title":"3.10 软件架构设计","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 软件架构的概述 ✅✅✅ 软件架构风格 ✅✅✅✅✅ 架构描述语言 ✅✅✅ 特定领域软件架构 ✅✅✅ 基于架构的软件开发 ✅✅✅✅ 软件质量属性 ✅✅✅✅✅ 软件架构评估 ✅✅✅✅✅ 软件产品线 ✅✅✅ 构建与中间件技术 ✅✅✅✅ web架构设计 ✅✅✅✅✅ "},{"id":21,"href":"/docs/example/architect-exam/3.11-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/","title":"3.11 系统安全分析与设计","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 安全基础技术 对称与非对称加密 ✅✅✅ 数字签名 ✅✅✅ 信息摘要 ✅✅✅ 网络安全 安全协议 ✅✅✅ 网络攻击 ✅✅ 等级保护标准 ✅✅ "},{"id":22,"href":"/docs/example/architect-exam/3.12-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/","title":"3.12 系统可靠性分析与设计","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 可靠性相关基本概念 ✅✅ 系统可靠性分析 ✅✅✅✅ 系统可靠性设计 ✅✅✅✅ "},{"id":23,"href":"/docs/example/architect-exam/3.13-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/","title":"3.13 项目管理","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 立项管理 ✅ 范围管理 ✅✅ 时间管理 ✅✅✅✅ 成本管理 ✅ 软件质量管理 ✅✅ 软件配置管理 ✅✅ "},{"id":24,"href":"/docs/example/architect-exam/3.14-%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD/","title":"3.14 专业英语","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # "},{"id":25,"href":"/docs/example/architect-exam/3.15-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%93%E6%A0%8F/","title":"3.15 案例分析专栏","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # 时间管理与成本管理 ✅✅✅✅ 系统安全性 ✅✅ 系统可靠性 ✅✅ "},{"id":26,"href":"/docs/example/architect-exam/3.16-%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E4%B8%93%E6%A0%8F/","title":"3.16 论文写作专栏","section":"3. 高级软考 - 系统架构师","content":" 课程内容提要 # "},{"id":27,"href":"/docs/example/golang/","title":"1. golang - 从入门到入土","section":"介绍","content":" 持续更新ing # "},{"id":28,"href":"/docs/example/gin/","title":"2. gin杂谈","section":"介绍","content":" 持续更新ing # "},{"id":29,"href":"/docs/example/architect-exam/","title":"3. 高级软考 - 系统架构师","section":"介绍","content":" 本博客只介绍“高级资格”里面的系统架构师，想考别的科目的朋友请参见官网 软考 1、考试介绍 # 系统架构师考试包含：3个科目，满分均为75分，45分为过线，需三科同时过线才算考过。 2、考试时间 # 每年具体那天考试不太确定，大概都是11月份。科目一全为选择题、科目二为案例分析题(第1道必答，后4道题选答2道，总共做3个题)、科目三论文作(四选一，不排除之后会变成二选一) 3、报名地址 # 需要格外注意的是：每个科目、每个省份的报名时间是不一样的，大概会在每年的4月和10月左右。系统架构师大概会在每年的10月左右。官方网站 软考\n4、考试内容 # 架构师考试内容太宽泛了，如果你和我一样是工作了才准备考的话，建议复习重点，45分和75分没啥区别 5、笔者过没过 # 算是比较幸运，我是一把过。希望学弟学妹们都能一把过。 6、备考资料 # 笔者的资料是从机构高价买的，现低价有偿分享给大家，所有资料打包 30元 即可获取，微信号：wys837，博主唯一的恰饭来源 😅\n资料主要有：\n2009-2022年的按年的真题及详细解析； 2009-2022年的按知识点的真题及详细解析； 新版系统架构师教材(2022年11月出版)，鉴别新版教材tips：新版教材分上下篇，总共20个章节； 某塞新版教材分析视频； 刷题小程序(非常适合上班族)； 按章节的知识点和真题排班的所有例题； 思维导图； 22年某赛讲义配套视频(309集，总共约48个小时的视频)； 相关的重要知识点补充、案例分析必背题目、示例论文精读、某赛讲义(我主要的复习参考)、答题卡等等。 "},{"id":30,"href":"/docs/example/algorthem/","title":"4. 数据结构与算法","section":"介绍","content":" 持续更新ing # "},{"id":31,"href":"/docs/example/leetcode/","title":"5. leetcode","section":"介绍","content":" 持续更新ing # github地址：https://github.com/yswang837/golang-leetcode\n"},{"id":32,"href":"/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/11-%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/","title":"11) 专项练习","section":"3.10 软件架构设计","content":" 1. 架构基础知识 # 2. 软件架构概念 # 在讲义312页\n"},{"id":33,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/1-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/","title":"1) 软件开发方法","section":"3.9 软件工程","content":" 1 软件开发方法🏁 # 常见的软件开发方法有4种：结构化法、原型法、面向对象方法、面向服务方法。\n整体图示如下图： 1.1 结构化法 # 用户至上；\n严格区分工作阶段，每个阶段有任务和结果；\n强调系统开发过程的整体性和全局性；\n系统开发过程工程化，文档资料标准化；\n自顶向下，逐步分解(求精)。\n1.2 原型法 # 适用于需求不明确的开发；\n包括抛弃型原型和进化型原型。\n1.3 面向对象方法 # 更好的复用性；\n关键在于建立一个全面、合理、统一的模型；\n分析、设计、实现三个阶段，界限不明确。\n1.4 面向服务方法 # SOA方法有三个主要的抽象级别：操作、服务、业务流程；\nSOA分为三个层次：基础设计层(底层服务构件)、应用结构层(服务之间的接口和服务级协定)和业务组织层(业务流程建模和服务流程编排)；\n服务建模：分为服务发现、服务规约和服务实现三个阶段。\n1.5 其他软件开发方法 # 形式化方法：所有东西均可证明/验证，而不是代码测试\n统一过程方法；\n敏捷开发方法；\n基于架构的开发方法ABSD。\n例题 学霸肯定对了 ↕ D A B "},{"id":34,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/2-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/","title":"2) 软件开发模型","section":"3.9 软件工程","content":" 2 软件开发模型 # 2.1 瀑布模型 # 严格先后完成每个阶段，上一阶段的输出时下一个阶段的输入，是结构化开发方法的典型模型，适合于需求明确的项目，对大型项目来说风险较大。 2.2 演化/迭代模型 # 2.3 增量模型 # 2.4 螺旋模型 # 螺旋模型=原型+瀑布模型，首次引入风险分析，适合大型项目。 2.5 原型模型 # 适合需求不明确的系统。若题目中指明“需求不明确”，选原型而不选螺旋模型\n2.6 喷泉模型 # 2.7 V模型 # 测试提前做，测试贯穿于始终。 2.8 构建组装模型 # 优点：快，成本低、可靠。\n缺点：构建库的建立需要慢慢积累。 2.9 快速应用开发模型RAD # 快速应用开发=瀑布模型(SDLC)+基于构建的开发(CBSD) 2.10 统一过程模型UP/RUP # 三大特点：用例驱动、以架构为中心、迭代和增量。\n四个阶段： 初始：确定项目范围和边界 细化：建立软件架构基础 构建：开发剩余的构建、构建组装与测试 交付：制作发布版本 2.11 敏捷开发模型 # 小步快跑的模式，适合小型项目。 例题 学霸肯定对了 ↕ C 学霸肯定对了 ↕ 学霸肯定对了 ↕ 学霸肯定对了 ↕ "},{"id":35,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/3-%E5%87%80%E5%AE%A4%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","title":"3) 净室软件工程与逆向工程","section":"3.9 软件工程","content":" 3. 净室软件工程与逆向工程 # 3.1 净室软件工程 # 3.2 逆向工程 # 山寨，比如说军事领域的航母 例题 学霸肯定对了 ↕ "},{"id":36,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/4-%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/","title":"4) 需求工程","section":"3.9 软件工程","content":" 4. 需求工程 # 4.1 概述 # 软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望。\n软件需求是指用户解决问题或达到目标所需的条件或能力，是系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明。\n需求工程包括两个维度：需求开发和需求管理。\n需求定义的产出是：需求规格说明书SRS。\n需要验证的产出是需求基线，需求管理的对象就是需求基线。 例题 学霸肯定对了 ↕ D 4.2 需求获取 # 从技术维度分：\n需求分为：业务需求、用户需求、系统需求。\n系统需求分为：功能需求、性能需求、设计约束需求(既不是功能需求、又不是性能需求的就属于设计约束需求)。\n从管理维度分：\n需求分为：基本需求、期望需求(比较难把握)、兴奋需求。 4.3 需求分析 # 需求分析包含两个方面：\n1、结构化需求分析SA；\n2、面向对象需求分析OOA。\n4.3.1 结构化需求分析SA # SA要求完成功能模型(DFD)、行为模型(STD)、数据模型(ER图)，其中数据字典起到解释的作用(学生：学号、名字、年龄)。 DFD：Data Flow Diagram，系统跟外界实体之间的交互，数据、加工交换的方式。\nSTD：State Transform Diagram\nE-R图：实体关系图\n例题 学霸肯定对了 ↕ C D 4.3.2 面向对象需求分析OOA # 面向对象的相关概念。 类的考察方法：\n实体类：永久保存某些数据。\n边界类：人机交互界面、系统交互接口之类的。\n实体类：非实体类和边界类就是实体类。\n1）UML # UML全称Unified Modeling Language，统一建模语言，UML由构造块、规则和公共机制；构造块中最重要的是事物和图；事物中包含结构事物是静态部分、行为事物是动态部分。 UML图同事物一样，也分为静态部分和动态部分，静态图称为结构图，动态图为行为图。得知道每种图大致是什么意思(标红的为重点)。 UML4+1视图，同架构的4+1视图可以一一对应 一般UML分析阶段建模主要是建立用例模型(用例图)和分析模型(类图) 4.4 需求定义 # 例题 学霸肯定对了 ↕ 4.5 需求验证 # "},{"id":37,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/5-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/","title":"5) 软件系统建模","section":"3.9 软件工程","content":" 软件系统建模 # "},{"id":38,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/6-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/","title":"6) 系统设计","section":"3.9 软件工程","content":" 系统设计 # "},{"id":39,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/7-%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%AF%84%E5%AE%A1/","title":"7) 测试与评审","section":"3.9 软件工程","content":" 测试与评审 # "},{"id":40,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/8-%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E4%B8%8E%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4/","title":"8) 系统运行与软件维护","section":"3.9 软件工程","content":" 系统运行与维护 # "},{"id":41,"href":"/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/9-%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/","title":"9) 专项练习","section":"3.9 软件工程","content":" 专项练习，讲义222页 # "},{"id":42,"href":"/docs/example/hidden/","title":"Hidden","section":"介绍","content":" This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); } Fronde cetera dextrae sequens pennis voce muneris # Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "},{"id":43,"href":"/docs/example/leetcode/1-hot100/","title":"1) Hot100","section":"5. leetcode","content":" hot100 # "}]