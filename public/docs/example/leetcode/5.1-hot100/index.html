<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="用golang1.19.4实现，将每题的函数粘贴到leetcode中即可一键运行，题目编号沿用leetcode的编号。项目代码：https://github.com/yswang837/golang-leetcode
*哈希 # map是典型的用空间换取时间的数据结构。
1.两数之和 # 地址：传送门 要求：O(N)时间复杂度 思路1：双重循环暴力破解，时间复杂度为O(n^2) 思路2：一次遍历，一边遍历，一边维护map，把num作为map的key，index作为map的value，可以O(N)时间复杂度解题。本题代码用思路2。 func twoSum(nums []int, target int) []int { ret := []int{-1, -1} if len(nums) == 0 { return ret } m := map[int]int{} for i, val := range nums { tmp := target - val if i2, ok := m[tmp]; ok { return []int{i, i2} } m[val] = i } return ret } 49.字母异位词分组 # 地址：传送门 思路：对strs的每个元素str进行排序，将排序的结果记录到map里面，其中，map的key为排序后的str，map的value为字母异位词的str的切片，最后返还一个由value为元素的二维切片就行。 func groupAnagrams(strs []string) [][]string { var ret [][]string if len(strs) == 0 { return ret } if len(strs) == 1 { ret = append(ret, strs) return ret } m := map[string][]string{} var b []byte for _, str := range strs { b = []byte(str) sort.">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="5.1 hot100" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://yswang837.github.io/docs/example/leetcode/5.1-hot100/" />

<title>5.1 hot100 | hello 小代</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css" integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz&#43;OQteg=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/zh.search.min.f03c73d3fbaf2ff77bc11e20fb0c68f9bf4729399e6f98844a8e0469dbbf717f.js" integrity="sha256-8Dxz0/uvL/d7wR4g&#43;wxo&#43;b9HKTmeb5iESo4Eadu/cX8=" crossorigin="anonymous"></script>
<link rel="alternate" type="application/rss+xml" href="https://yswang837.github.io/docs/example/leetcode/5.1-hot100/index.xml" title="hello 小代" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>hello 小代</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/example/" class="">介绍</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-0172079bf31c2e1230a2ba418e74787a" class="toggle"  />
    <label for="section-0172079bf31c2e1230a2ba418e74787a" class="flex justify-between">
      <a href="/docs/example/golang/" class="">1. golang - 专题精讲</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/golang/1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="">1 并发</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-777a1736a727cd6e825002af5c691cae" class="toggle"  />
    <label for="section-777a1736a727cd6e825002af5c691cae" class="flex justify-between">
      <a href="/docs/example/gin/" class="">2. gin杂谈</a>
    </label>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-6c4eae7067e5dfff5c2e4406248debee" class="toggle"  />
    <label for="section-6c4eae7067e5dfff5c2e4406248debee" class="flex justify-between">
      <a href="/docs/example/architect-exam/" class="">3. 高级软考 - 系统架构师</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="">3.1 计算机组成与体系结构</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="">3.2 操作系统</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" class="">3.3 数据库系统</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="">3.4 计算机网络</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.5-%E6%95%B0%E5%AD%97%E4%B8%8E%E7%BB%8F%E6%B5%8E%E7%AE%A1%E7%90%86/" class="">3.5 数字与经济管理</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.6-%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7/" class="">3.6 系统配置与性能评价</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.7-%E7%9F%A5%E8%AF%86%E4%BA%A7%E6%9D%83%E4%B8%8E%E6%A0%87%E5%87%86%E5%8C%96/" class="">3.7 知识产权与标准化</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.8-%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF%E5%8C%96%E6%88%98%E7%95%A5%E4%B8%8E%E5%AE%9E%E6%96%BD/" class="">3.8 企业信息化战略与实施</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" class="">3.9 软件工程</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/1-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/" class="">1) 软件开发方法</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/2-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B/" class="">2) 软件开发模型</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/3-%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B/" class="">3) 需求工程</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/4-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="">4) 系统设计</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/5-%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1/" class="">5) 软件系统建模</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/6-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95/" class="">6) 软件测试与调试</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.9-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/7-%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E4%B8%8E%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4/" class="">7) 系统运行与软件维护</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="">3.10 软件架构设计</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/1-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A6%82%E8%BF%B0/" class="">1) 软件架构的概述</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/2-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/" class="">2) 软件架构风格</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/3-%E7%89%B9%E5%AE%9A%E9%A2%86%E5%9F%9F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84/" class="">3) 特定领域软件架构</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/4-%E5%9F%BA%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/" class="">4) 基于架构的软件开发</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/5-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7/" class="">5) 软件质量属性</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/6-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/" class="">6) 软件架构评估</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/7-%E8%BD%AF%E4%BB%B6%E4%BA%A7%E5%93%81%E7%BA%BF/" class="">7) 软件产品线</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/8-%E6%9E%84%E4%BB%B6%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF/" class="">8) 构建与中间件技术</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.10-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/9-web%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/" class="">9) web架构设计</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.11-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7/" class="">3.11 系统安全性和可靠性</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.12-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" class="">3.12 项目管理</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.13-%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD/" class="">3.13 专业英语</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.14-%E5%85%B6%E4%BB%96/" class="">3.14 其他</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.15-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%93%E6%A0%8F/" class="">3.15 案例分析专栏</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.16-%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E4%B8%93%E6%A0%8F/" class="">3.16 论文写作专栏</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.16-%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E4%B8%93%E6%A0%8F/1-nosql%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" class="">NoSQL数据库技术及其应用</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.16-%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E4%B8%93%E6%A0%8F/2-%E8%AE%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" class="">论微服务架构及其应用</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.16-%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E4%B8%93%E6%A0%8F/3-%E8%AE%BA%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/" class="">论软件的可靠性设计</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.16-%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E4%B8%93%E6%A0%8F/4-%E8%AE%BA%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC/" class="">论软件系统架构风格</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.16-%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E4%B8%93%E6%A0%8F/5-%E8%AE%BA%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0/" class="">论软件系统架构评估及其应用</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/architect-exam/3.16-%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E4%B8%93%E6%A0%8F/6-%E8%AE%BA%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" class="">论软件开发模型及其应用</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c5af2a1cf2778ff160886bf03e434863" class="toggle"  />
    <label for="section-c5af2a1cf2778ff160886bf03e434863" class="flex justify-between">
      <a href="/docs/example/algorthem/" class="">4. 数据结构与算法</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/algorthem/4.1-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="">4.1 排序算法</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-931d8f340adf73346e40d4b227426621" class="toggle" checked />
    <label for="section-931d8f340adf73346e40d4b227426621" class="flex justify-between">
      <a href="/docs/example/leetcode/" class="">5. leetcode</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/leetcode/5.1-hot100/" class="active">5.1 hot100</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/leetcode/5.2-%E5%8F%8C%E6%8C%87%E9%92%88%E7%A7%92%E6%9D%80%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/" class="">5.2 双指针秒杀数组问题</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/leetcode/5.3-%E5%89%8D%E7%BC%80%E5%92%8C%E5%8F%8A%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/" class="">5.3 前缀和及差分数组</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/leetcode/5.4-%E5%8F%8C%E6%8C%87%E9%92%88%E7%A7%92%E6%9D%80%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/" class="">5.4 双指针秒杀链表问题</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/leetcode/5.5-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" class="">5.5 滑动窗口</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/leetcode/5.6-%E4%BA%8C%E5%8F%89%E6%A0%91/" class="">5.6 二叉树</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/leetcode/5.7-%E9%9D%A2%E7%BB%8F/" class="">5.7 面经</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>















</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>5.1 hot100</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#哈希">*哈希</a>
      <ul>
        <li><a href="#1两数之和">1.两数之和</a></li>
        <li><a href="#49字母异位词分组">49.字母异位词分组</a></li>
        <li><a href="#128最长连续序列">128.最长连续序列</a></li>
      </ul>
    </li>
    <li><a href="#双指针">*双指针</a>
      <ul>
        <li><a href="#283移动零">283.移动零</a></li>
        <li><a href="#11盛最多水的容器">11.盛最多水的容器</a></li>
        <li><a href="#15三数之和">15.三数之和</a></li>
        <li><a href="#42接雨水">42.接雨水</a></li>
      </ul>
    </li>
    <li><a href="#滑动窗口">*滑动窗口</a>
      <ul>
        <li><a href="#3无重复字符的最长子串">3.无重复字符的最长子串</a></li>
        <li><a href="#438找到字符串中所有字母异位词">438.找到字符串中所有字母异位词</a></li>
      </ul>
    </li>
    <li><a href="#子串">*子串</a>
      <ul>
        <li><a href="#560和为k的子数组">560.和为K的子数组</a></li>
        <li><a href="#239滑动窗口最大值">239.滑动窗口最大值</a></li>
        <li><a href="#76最小覆盖子串">76.最小覆盖子串</a></li>
      </ul>
    </li>
    <li><a href="#普通数组">*普通数组</a>
      <ul>
        <li><a href="#53最大子数组和">53.最大子数组和</a></li>
        <li><a href="#56合并区间">56.合并区间</a></li>
        <li><a href="#189轮转数组">189.轮转数组</a></li>
        <li><a href="#238除自身以外数组的乘积">238.除自身以外数组的乘积</a></li>
        <li><a href="#41缺失的第一个正数">41.缺失的第一个正数</a></li>
      </ul>
    </li>
    <li><a href="#矩阵">*矩阵</a>
      <ul>
        <li><a href="#73矩阵置零">73.矩阵置零</a></li>
        <li><a href="#54螺旋矩阵">54.螺旋矩阵</a></li>
        <li><a href="#48旋转图像">48.旋转图像</a></li>
        <li><a href="#240搜索二维矩阵ii">240.搜索二维矩阵II</a></li>
      </ul>
    </li>
    <li><a href="#链表">*链表</a>
      <ul>
        <li><a href="#160-相交链表">160. 相交链表</a></li>
        <li><a href="#206反转链表">206.反转链表</a></li>
        <li><a href="#146lru缓存">146.LRU缓存</a></li>
        <li><a href="#234-回文链表">234. 回文链表</a></li>
        <li><a href="#141-环形链表">141. 环形链表</a></li>
        <li><a href="#142-环形链表-ii">142. 环形链表 II</a></li>
        <li><a href="#21-合并两个有序链表">21. 合并两个有序链表</a></li>
        <li><a href="#2-两数相加">2. 两数相加</a></li>
        <li><a href="#19-删除链表的倒数第-n-个结点">19. 删除链表的倒数第 N 个结点</a></li>
        <li><a href="#24-两两交换链表中的节点">24. 两两交换链表中的节点</a></li>
        <li><a href="#25-k-个一组翻转链表">25. K 个一组翻转链表</a></li>
        <li><a href="#138-随机链表的复制">138. 随机链表的复制</a></li>
        <li><a href="#148-排序链表">148. 排序链表</a></li>
        <li><a href="#23-合并-k-个升序链表">23. 合并 K 个升序链表</a></li>
      </ul>
    </li>
    <li><a href="#二叉树">*二叉树</a>
      <ul>
        <li><a href="#94-二叉树的中序遍历">94. 二叉树的中序遍历</a></li>
        <li><a href="#104-二叉树的最大深度">104. 二叉树的最大深度</a></li>
        <li><a href="#226-翻转二叉树">226. 翻转二叉树</a></li>
        <li><a href="#101-对称二叉树">101. 对称二叉树</a></li>
        <li><a href="#543-二叉树的直径">543. 二叉树的直径</a></li>
        <li><a href="#102-二叉树的层序遍历">102. 二叉树的层序遍历</a></li>
        <li><a href="#108-将有序数组转换为二叉搜索树">108. 将有序数组转换为二叉搜索树</a></li>
        <li><a href="#98-验证二叉搜索树">98. 验证二叉搜索树</a></li>
        <li><a href="#230-二叉搜索树中第k小的元素">230. 二叉搜索树中第K小的元素</a></li>
        <li><a href="#199-二叉树的右视图">199. 二叉树的右视图</a></li>
        <li><a href="#114-二叉树展开为链表">114. 二叉树展开为链表</a></li>
        <li><a href="#105-从前序与中序遍历序列构造二叉树">105. 从前序与中序遍历序列构造二叉树</a></li>
        <li><a href="#437-路径总和-iii">437. 路径总和 III</a></li>
        <li><a href="#236-二叉树的最近公共祖先">236. 二叉树的最近公共祖先</a></li>
        <li><a href="#124-二叉树中的最大路径和">124. 二叉树中的最大路径和</a></li>
      </ul>
    </li>
    <li><a href="#图论">*图论</a>
      <ul>
        <li><a href="#200-岛屿数量">200. 岛屿数量</a></li>
        <li><a href="#994-腐烂的橘子">994. 腐烂的橘子</a></li>
        <li><a href="#207-课程表">207. 课程表</a></li>
        <li><a href="#208-实现-trie-前缀树">208. 实现 Trie (前缀树)</a></li>
      </ul>
    </li>
    <li><a href="#回溯">*回溯</a>
      <ul>
        <li><a href="#46-全排列">46. 全排列</a></li>
        <li><a href="#78-子集">78. 子集</a></li>
        <li><a href="#17-电话号码的字母组合">17. 电话号码的字母组合</a></li>
        <li><a href="#39-组合总和">39. 组合总和</a></li>
        <li><a href="#22-括号生成">22. 括号生成</a></li>
        <li><a href="#79-单词搜索">79. 单词搜索</a></li>
        <li><a href="#131-分割回文串">131. 分割回文串</a></li>
        <li><a href="#51-n-皇后">51. N 皇后</a></li>
      </ul>
    </li>
    <li><a href="#二分查找">*二分查找</a>
      <ul>
        <li><a href="#35-搜索插入位置">35. 搜索插入位置</a></li>
        <li><a href="#74-搜索二维矩阵">74. 搜索二维矩阵</a></li>
        <li><a href="#34-在排序数组中查找元素的第一个和最后一个位置">34. 在排序数组中查找元素的第一个和最后一个位置</a></li>
        <li><a href="#33搜索旋转排序数组">33.搜索旋转排序数组</a></li>
        <li><a href="#153-寻找旋转排序数组中的最小值">153. 寻找旋转排序数组中的最小值</a></li>
        <li><a href="#4-寻找两个正序数组的中位数">4. 寻找两个正序数组的中位数</a></li>
      </ul>
    </li>
    <li><a href="#栈">*栈</a>
      <ul>
        <li><a href="#20-有效的括号">20. 有效的括号</a></li>
        <li><a href="#155-最小栈">155. 最小栈</a></li>
        <li><a href="#394-字符串解码">394. 字符串解码</a></li>
        <li><a href="#739-每日温度">739. 每日温度</a></li>
        <li><a href="#84-柱状图中最大的矩形">84. 柱状图中最大的矩形</a></li>
      </ul>
    </li>
    <li><a href="#堆">*堆</a>
      <ul>
        <li><a href="#215-数组中的第k个最大元素">215. 数组中的第K个最大元素</a></li>
        <li><a href="#347-前-k-个高频元素">347. 前 K 个高频元素</a></li>
        <li><a href="#295-数据流的中位数">295. 数据流的中位数</a></li>
      </ul>
    </li>
    <li><a href="#贪心算法">*贪心算法</a>
      <ul>
        <li><a href="#121-买卖股票的最佳时机">121. 买卖股票的最佳时机</a></li>
        <li><a href="#55-跳跃游戏">55. 跳跃游戏</a></li>
        <li><a href="#45-跳跃游戏-ii">45. 跳跃游戏 II</a></li>
        <li><a href="#763-划分字母区间">763. 划分字母区间</a></li>
      </ul>
    </li>
    <li><a href="#动态规划">*动态规划</a>
      <ul>
        <li><a href="#70-爬楼梯">70. 爬楼梯</a></li>
        <li><a href="#118-杨辉三角">118. 杨辉三角</a></li>
        <li><a href="#198-打家劫舍">198. 打家劫舍</a></li>
        <li><a href="#279-完全平方数">279. 完全平方数</a></li>
        <li><a href="#322-零钱兑换">322. 零钱兑换</a></li>
        <li><a href="#139-单词拆分">139. 单词拆分</a></li>
        <li><a href="#300-最长递增子序列">300. 最长递增子序列</a></li>
        <li><a href="#152-乘积最大子数组">152. 乘积最大子数组</a></li>
        <li><a href="#416-分割等和子集">416. 分割等和子集</a></li>
        <li><a href="#32-最长有效括号">32. 最长有效括号</a></li>
      </ul>
    </li>
    <li><a href="#多维动态规划">*多维动态规划</a>
      <ul>
        <li><a href="#62-不同路径">62. 不同路径</a></li>
        <li><a href="#64-最小路径和">64. 最小路径和</a></li>
        <li><a href="#5-最长回文子串">5. 最长回文子串</a></li>
        <li><a href="#1143-最长公共子序列">1143. 最长公共子序列</a></li>
        <li><a href="#72-编辑距离">72. 编辑距离</a></li>
      </ul>
    </li>
    <li><a href="#技巧">*技巧</a>
      <ul>
        <li><a href="#136-只出现一次的数字">136. 只出现一次的数字</a></li>
        <li><a href="#169-多数元素">169. 多数元素</a></li>
        <li><a href="#75-颜色分类">75. 颜色分类</a></li>
        <li><a href="#31-下一个排列">31. 下一个排列</a></li>
        <li><a href="#287-寻找重复数">287. 寻找重复数</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><p>  用golang1.19.4实现，将每题的函数粘贴到leetcode中即可一键运行，题目编号沿用leetcode的编号。项目代码：https://github.com/yswang837/golang-leetcode</p>
<h2 id="哈希">
  *哈希
  <a class="anchor" href="#%e5%93%88%e5%b8%8c">#</a>
</h2>
<p>  map是典型的用空间换取时间的数据结构。</p>
<h3 id="1两数之和">
  1.两数之和
  <a class="anchor" href="#1%e4%b8%a4%e6%95%b0%e4%b9%8b%e5%92%8c">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：O(N)时间复杂度</li>
<li>思路1：双重循环暴力破解，时间复杂度为O(n^2)</li>
<li>思路2：一次遍历，一边遍历，一边维护map，把num作为map的key，index作为map的value，可以O(N)时间复杂度解题。本题代码用思路2。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">twoSum</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">target</span> <span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">nums</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">val</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">tmp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">target</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">val</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i2</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">tmp</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> []<span style="color:#66d9ef">int</span>{<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">i2</span>}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">val</span>] = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="49字母异位词分组">
  49.字母异位词分组
  <a class="anchor" href="#49%e5%ad%97%e6%af%8d%e5%bc%82%e4%bd%8d%e8%af%8d%e5%88%86%e7%bb%84">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>思路：对strs的每个元素str进行排序，将排序的结果记录到map里面，其中，map的key为排序后的str，map的value为字母异位词的str的切片，最后返还一个由value为元素的二维切片就行。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">groupAnagrams</span>(<span style="color:#a6e22e">strs</span> []<span style="color:#66d9ef">string</span>) [][]<span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ret</span> [][]<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">strs</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">strs</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ret</span> = append(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">strs</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>][]<span style="color:#66d9ef">string</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">str</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">strs</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">b</span> = []byte(<span style="color:#a6e22e">str</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">sort</span>.<span style="color:#a6e22e">Slice</span>(<span style="color:#a6e22e">b</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>[<span style="color:#a6e22e">i</span>] &lt; <span style="color:#a6e22e">b</span>[<span style="color:#a6e22e">j</span>]
</span></span><span style="display:flex;"><span>		})
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> string(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>] = append(<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span>], <span style="color:#a6e22e">str</span>) <span style="color:#75715e">// m[key]在不在都是将新的str append到对应的切片上。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">val</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ret</span> = append(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">val</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="128最长连续序列">
  128.最长连续序列
  <a class="anchor" href="#128%e6%9c%80%e9%95%bf%e8%bf%9e%e7%bb%ad%e5%ba%8f%e5%88%97">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：O(N)时间复杂度</li>
<li>思路：首先将nums装入map[int]bool中(方便取到的值能直接当做bool用)，找到map中，每个连续段key的起始值，向后循环，求出每段的长度，和当前长度就max，循环结束，当前的max就是最大的max。这是O(N)时间复杂度，注意n个O(1)也是O(1),所以即使是嵌套循环，也不是O(N^2)</li>
<li>例子：m[1:true,2:true,3:true,4:true,100:true,200:true]，每段的长度是4,1,1,两两求max就是4</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">longestConsecutive</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">nums</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">bool</span>{}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>,<span style="color:#a6e22e">val</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nums</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">val</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">key</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">currentLength</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">flag</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">key</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">flag</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">flag</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">currentLength</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>				}<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ret</span> = <span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">currentLength</span>,<span style="color:#a6e22e">ret</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span>&gt;<span style="color:#a6e22e">j</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="双指针">
  *双指针
  <a class="anchor" href="#%e5%8f%8c%e6%8c%87%e9%92%88">#</a>
</h2>
<h3 id="283移动零">
  283.移动零
  <a class="anchor" href="#283%e7%a7%bb%e5%8a%a8%e9%9b%b6">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：原位操作，且尽量减少操作次数</li>
<li>思路：原位操作意味着只能通过交换元素来实现，初始的快慢指针都是0，当快指针小于len时循环，很巧妙，操作次数也很少</li>
<li>例子：[0,1,0,3,12], [1,0,0,3,12], [1,3,0,0,12], [1,3,12,0,0]</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">moveZeroes</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">slow</span>, <span style="color:#a6e22e">fast</span>, <span style="color:#a6e22e">length</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">nums</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">fast</span> &lt; <span style="color:#a6e22e">length</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">fast</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">slow</span>], <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">fast</span>] = <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">fast</span>], <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">slow</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">slow</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fast</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="11盛最多水的容器">
  11.盛最多水的容器
  <a class="anchor" href="#11%e7%9b%9b%e6%9c%80%e5%a4%9a%e6%b0%b4%e7%9a%84%e5%ae%b9%e5%99%a8">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：不能倾斜容器</li>
<li>思路：双指针，一个在左，一个在右，两两求面积最大的矩形即可。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxArea</span>(<span style="color:#a6e22e">height</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">height</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> len(<span style="color:#a6e22e">height</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">height</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">maxarea</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">left</span> &lt; <span style="color:#a6e22e">right</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">h</span>,<span style="color:#a6e22e">flag</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">subabs</span>(<span style="color:#a6e22e">height</span>[<span style="color:#a6e22e">left</span>], <span style="color:#a6e22e">height</span>[<span style="color:#a6e22e">right</span>])
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">right</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">left</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">maxarea</span> = <span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">h</span><span style="color:#f92672">*</span><span style="color:#a6e22e">w</span>,<span style="color:#a6e22e">maxarea</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">flag</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">right</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">left</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">maxarea</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span>&gt;<span style="color:#a6e22e">j</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">subabs</span>(<span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//左是否大于右
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#a6e22e">j</span> &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">j</span>, <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="15三数之和">
  15.三数之和
  <a class="anchor" href="#15%e4%b8%89%e6%95%b0%e4%b9%8b%e5%92%8c">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：答案中不可以包含重复的三元组。</li>
<li>思路：</li>
</ul>
<h3 id="42接雨水">
  42.接雨水
  <a class="anchor" href="#42%e6%8e%a5%e9%9b%a8%e6%b0%b4">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/trapping-rain-water/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h2 id="滑动窗口">
  *滑动窗口
  <a class="anchor" href="#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3">#</a>
</h2>
<h3 id="3无重复字符的最长子串">
  3.无重复字符的最长子串
  <a class="anchor" href="#3%e6%97%a0%e9%87%8d%e5%a4%8d%e5%ad%97%e7%ac%a6%e7%9a%84%e6%9c%80%e9%95%bf%e5%ad%90%e4%b8%b2">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="438找到字符串中所有字母异位词">
  438.找到字符串中所有字母异位词
  <a class="anchor" href="#438%e6%89%be%e5%88%b0%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%ad%e6%89%80%e6%9c%89%e5%ad%97%e6%af%8d%e5%bc%82%e4%bd%8d%e8%af%8d">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h2 id="子串">
  *子串
  <a class="anchor" href="#%e5%ad%90%e4%b8%b2">#</a>
</h2>
<h3 id="560和为k的子数组">
  560.和为K的子数组
  <a class="anchor" href="#560%e5%92%8c%e4%b8%bak%e7%9a%84%e5%ad%90%e6%95%b0%e7%bb%84">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="239滑动窗口最大值">
  239.滑动窗口最大值
  <a class="anchor" href="#239%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e6%9c%80%e5%a4%a7%e5%80%bc">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="76最小覆盖子串">
  76.最小覆盖子串
  <a class="anchor" href="#76%e6%9c%80%e5%b0%8f%e8%a6%86%e7%9b%96%e5%ad%90%e4%b8%b2">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h2 id="普通数组">
  *普通数组
  <a class="anchor" href="#%e6%99%ae%e9%80%9a%e6%95%b0%e7%bb%84">#</a>
</h2>
<h3 id="53最大子数组和">
  53.最大子数组和
  <a class="anchor" href="#53%e6%9c%80%e5%a4%a7%e5%ad%90%e6%95%b0%e7%bb%84%e5%92%8c">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="56合并区间">
  56.合并区间
  <a class="anchor" href="#56%e5%90%88%e5%b9%b6%e5%8c%ba%e9%97%b4">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="189轮转数组">
  189.轮转数组
  <a class="anchor" href="#189%e8%bd%ae%e8%bd%ac%e6%95%b0%e7%bb%84">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="238除自身以外数组的乘积">
  238.除自身以外数组的乘积
  <a class="anchor" href="#238%e9%99%a4%e8%87%aa%e8%ba%ab%e4%bb%a5%e5%a4%96%e6%95%b0%e7%bb%84%e7%9a%84%e4%b9%98%e7%a7%af">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="41缺失的第一个正数">
  41.缺失的第一个正数
  <a class="anchor" href="#41%e7%bc%ba%e5%a4%b1%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aa%e6%ad%a3%e6%95%b0">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h2 id="矩阵">
  *矩阵
  <a class="anchor" href="#%e7%9f%a9%e9%98%b5">#</a>
</h2>
<h3 id="73矩阵置零">
  73.矩阵置零
  <a class="anchor" href="#73%e7%9f%a9%e9%98%b5%e7%bd%ae%e9%9b%b6">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="54螺旋矩阵">
  54.螺旋矩阵
  <a class="anchor" href="#54%e8%9e%ba%e6%97%8b%e7%9f%a9%e9%98%b5">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="48旋转图像">
  48.旋转图像
  <a class="anchor" href="#48%e6%97%8b%e8%bd%ac%e5%9b%be%e5%83%8f">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="240搜索二维矩阵ii">
  240.搜索二维矩阵II
  <a class="anchor" href="#240%e6%90%9c%e7%b4%a2%e4%ba%8c%e7%bb%b4%e7%9f%a9%e9%98%b5ii">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h2 id="链表">
  *链表
  <a class="anchor" href="#%e9%93%be%e8%a1%a8">#</a>
</h2>
<h3 id="160-相交链表">
  160. 相交链表
  <a class="anchor" href="#160-%e7%9b%b8%e4%ba%a4%e9%93%be%e8%a1%a8">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：返回的依旧是个链表</li>
<li>思路：难点在于两个链表的长度不一定相等，导致不知道什么时候会相交，链表A+链表B的长度肯定相等，那么两个链表的值第一次相等的时候，就是相交节点的位置。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getIntersectionNode</span>(<span style="color:#a6e22e">headA</span>, <span style="color:#a6e22e">headB</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">headA</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">headB</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">curA</span>, <span style="color:#a6e22e">curB</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">headA</span>, <span style="color:#a6e22e">headB</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">curA</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">curB</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">curA</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">curA</span> = <span style="color:#a6e22e">headB</span>
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">curA</span> = <span style="color:#a6e22e">curA</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">curB</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">curB</span> = <span style="color:#a6e22e">headA</span>
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">curB</span> = <span style="color:#a6e22e">curB</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">curA</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="206反转链表">
  206.反转链表
  <a class="anchor" href="#206%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：在遍历链表时，将当前节点的next指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">reverseList</span>(<span style="color:#a6e22e">head</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">head</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">pre</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cur</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">cur</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">pre</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">pre</span> = <span style="color:#a6e22e">cur</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cur</span> = <span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pre</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="146lru缓存">
  146.LRU缓存
  <a class="anchor" href="#146lru%e7%bc%93%e5%ad%98">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/lru-cache/">传送门</a></li>
<li>要求：get和put操作必须以O(1)的时间复杂度</li>
<li>思路：假设缓存容量是length=5，则ABCDBEFG最终会存成FGEBD，get操作需要O(1)时间复杂度，所以用map来查，put操作需要O(1)时间复杂度，并且要在头部插入，尾部删除，所以用双向链表来存，head &lt;-&gt; &hellip; node &hellip; &lt;-&gt; tail，PUT：元素要在头部插入，容量满了之后，在尾部删除。&mdash;-&gt; 双向链表，GET：在O(1)内查到元素，该元素从原位置删除，再插入头部 &mdash;-&gt; map(key,node)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Node</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">prev</span>, <span style="color:#a6e22e">next</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">LRUCache</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">capacity</span>   <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">head</span>, <span style="color:#a6e22e">tail</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">hashMap</span>    <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Constructor</span>(<span style="color:#a6e22e">capacity</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">LRUCache</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">head</span>, <span style="color:#a6e22e">tail</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Node</span>{}, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Node</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// head &lt;-&gt; tail
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">tail</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">tail</span>.<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">LRUCache</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">capacity</span>: <span style="color:#a6e22e">capacity</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">head</span>:     <span style="color:#a6e22e">head</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">tail</span>:     <span style="color:#a6e22e">tail</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">hashMap</span>:  <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>{},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">LRUCache</span>) <span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">hashMap</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">remove</span>(<span style="color:#a6e22e">node</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">insert</span>(<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span>, <span style="color:#a6e22e">node</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">LRUCache</span>) <span style="color:#a6e22e">Put</span>(<span style="color:#a6e22e">key</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">hashMap</span>[<span style="color:#a6e22e">key</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 如果在map里面，属于更新
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">value</span> = <span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">remove</span>(<span style="color:#a6e22e">node</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">insert</span>(<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span>, <span style="color:#a6e22e">node</span>)
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">newNode</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Node</span>{<span style="color:#a6e22e">key</span>: <span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">value</span>: <span style="color:#a6e22e">value</span>}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">insert</span>(<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">head</span>, <span style="color:#a6e22e">newNode</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">hashMap</span>[<span style="color:#a6e22e">key</span>] = <span style="color:#a6e22e">newNode</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">hashMap</span>) &gt; <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">capacity</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">lastNode</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">tail</span>.<span style="color:#a6e22e">prev</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">remove</span>(<span style="color:#a6e22e">lastNode</span>)
</span></span><span style="display:flex;"><span>			delete(<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">hashMap</span>, <span style="color:#a6e22e">lastNode</span>.<span style="color:#a6e22e">key</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">remove</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// prev &lt;-&gt; node &lt;-&gt; next
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">prev</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">next</span> <span style="color:#75715e">// prev -&gt; next
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">prev</span> <span style="color:#75715e">// prev &lt;- next
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">insert</span>(<span style="color:#a6e22e">head</span>, <span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// head &lt;-&gt; next
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// head &lt;-&gt; node &lt;-&gt; next
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">next</span> <span style="color:#75715e">// node -&gt; next
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">node</span> <span style="color:#75715e">// node &lt;- next
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">node</span> <span style="color:#75715e">// head -&gt; node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">prev</span> = <span style="color:#a6e22e">head</span> <span style="color:#75715e">// head &lt;- node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="234-回文链表">
  234. 回文链表
  <a class="anchor" href="#234-%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题</li>
<li>思路1：遍历一遍链表，将结果存到数组里面，双指针遍历该数组，都相等则是回文链表。</li>
<li>思路2：快慢指针，慢指针走一步，快指针走两步，在慢指针的位置断开链表，并将前半部分链表反转一下，在遍历两个链表，都相等则是回文链表。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 思路1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isPalindrome</span>(<span style="color:#a6e22e">head</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ret</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">head</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ret</span> = append(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Val</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">head</span> = <span style="color:#a6e22e">head</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">ret</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">left</span> &lt; <span style="color:#a6e22e">right</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ret</span>[<span style="color:#a6e22e">left</span>] <span style="color:#f92672">!=</span> <span style="color:#a6e22e">ret</span>[<span style="color:#a6e22e">right</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">left</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">right</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 思路2
</span></span></span></code></pre></div><h3 id="141-环形链表">
  141. 环形链表
  <a class="anchor" href="#141-%e7%8e%af%e5%bd%a2%e9%93%be%e8%a1%a8">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：无</li>
<li>思路：快慢指针，同时走，快的一次走两步，慢的一次走一步，相等就有环</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hasCycle</span>(<span style="color:#a6e22e">head</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">head</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">slow</span>, <span style="color:#a6e22e">fast</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">head</span>, <span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">fast</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">fast</span>.<span style="color:#a6e22e">Next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">slow</span> = <span style="color:#a6e22e">slow</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fast</span> = <span style="color:#a6e22e">fast</span>.<span style="color:#a6e22e">Next</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fast</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">slow</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="142-环形链表-ii">
  142. 环形链表 II
  <a class="anchor" href="#142-%e7%8e%af%e5%bd%a2%e9%93%be%e8%a1%a8-ii">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：我们假设快慢指针相遇时，慢指针slow走了k步，那么快指针fast一定走了2k步，即fast一定比slow多走了k步，这多走的k步其实就是fast指针在环里转圈圈，所以k的值就是环长度的「整数倍」，假设相遇点距环的起点的距离为m，环的起点距头结点head的距离一定为k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。所以当它们以同样的速度再次相遇时，就是环的起点所在位置。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">detectCycle</span>(<span style="color:#a6e22e">head</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">head</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">slow</span>, <span style="color:#a6e22e">fast</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">head</span>, <span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">fast</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">fast</span>.<span style="color:#a6e22e">Next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">slow</span> = <span style="color:#a6e22e">slow</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fast</span> = <span style="color:#a6e22e">fast</span>.<span style="color:#a6e22e">Next</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fast</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">slow</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 执行到这里，可能是有环break了，可能没环退出循环了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fast</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">fast</span>.<span style="color:#a6e22e">Next</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 没环直接return
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 执行到这里，必定有环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">slow</span> = <span style="color:#a6e22e">head</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">slow</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">fast</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">slow</span> = <span style="color:#a6e22e">slow</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fast</span> = <span style="color:#a6e22e">fast</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">slow</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="21-合并两个有序链表">
  21. 合并两个有序链表
  <a class="anchor" href="#21-%e5%90%88%e5%b9%b6%e4%b8%a4%e4%b8%aa%e6%9c%89%e5%ba%8f%e9%93%be%e8%a1%a8">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：无</li>
<li>思路：用一个虚拟节点dummy方便处理。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mergeTwoLists</span>(<span style="color:#a6e22e">list1</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>, <span style="color:#a6e22e">list2</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">list1</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">list2</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">list2</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">list1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dummy</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ListNode</span>{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">nil</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cur</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dummy</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">list1</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">list2</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">list1</span>.<span style="color:#a6e22e">Val</span> &gt; <span style="color:#a6e22e">list2</span>.<span style="color:#a6e22e">Val</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">list2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">list2</span> = <span style="color:#a6e22e">list2</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">list1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">list1</span> = <span style="color:#a6e22e">list1</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cur</span> = <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">list1</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">list1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">list2</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">list2</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dummy</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// dummy,cur
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// l1: 1-&gt;2-&gt;4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// l2: 1-&gt;3-&gt;4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//             cur
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// l1: dummy -&gt; 1 -&gt; 2 -&gt; 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#a6e22e">cur</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// l2: dummy -&gt; 1 -&gt; 1 -&gt; 3 -&gt; 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                         <span style="color:#a6e22e">cur</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// l1: dummy -&gt; 1 -&gt; 1 -&gt; 2 -&gt; 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                              <span style="color:#a6e22e">cur</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// l2: dummy -&gt; 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                   <span style="color:#a6e22e">cur</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// l1: dummy -&gt; 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 // 循环终止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                   <span style="color:#a6e22e">cur</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// l2: dummy -&gt; 1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4
</span></span></span></code></pre></div><h3 id="2-两数相加">
  2. 两数相加
  <a class="anchor" href="#2-%e4%b8%a4%e6%95%b0%e7%9b%b8%e5%8a%a0">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="19-删除链表的倒数第-n-个结点">
  19. 删除链表的倒数第 N 个结点
  <a class="anchor" href="#19-%e5%88%a0%e9%99%a4%e9%93%be%e8%a1%a8%e7%9a%84%e5%80%92%e6%95%b0%e7%ac%ac-n-%e4%b8%aa%e7%bb%93%e7%82%b9">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：一次遍历</li>
<li>思路：快慢指针，fast先走N步，再和慢指针一起走，fast负责探路，slow负责处理。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">removeNthFromEnd</span>(<span style="color:#a6e22e">head</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>, <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">head</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dummy</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ListNode</span>{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#a6e22e">head</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">slow</span>, <span style="color:#a6e22e">fast</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dummy</span>, <span style="color:#a6e22e">dummy</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">&lt;=</span><span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> { <span style="color:#75715e">// 因为加了个虚拟节点dummy，所以需要等于，为什么要加dummy的原因在于：为了删除第一个节点的case
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">fast</span> = <span style="color:#a6e22e">fast</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">fast</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fast</span> = <span style="color:#a6e22e">fast</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">slow</span> = <span style="color:#a6e22e">slow</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 执行到这里fast已经是nil了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">slow</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">slow</span>.<span style="color:#a6e22e">Next</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dummy</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//              f
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// [a,1,2,3,4,5], n = 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//      f
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// [a,1], n = 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//        f
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// [a,1,2], n = 1
</span></span></span></code></pre></div><h3 id="24-两两交换链表中的节点">
  24. 两两交换链表中的节点
  <a class="anchor" href="#24-%e4%b8%a4%e4%b8%a4%e4%ba%a4%e6%8d%a2%e9%93%be%e8%a1%a8%e4%b8%ad%e7%9a%84%e8%8a%82%e7%82%b9">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="25-k-个一组翻转链表">
  25. K 个一组翻转链表
  <a class="anchor" href="#25-k-%e4%b8%aa%e4%b8%80%e7%bb%84%e7%bf%bb%e8%bd%ac%e9%93%be%e8%a1%a8">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="138-随机链表的复制">
  138. 随机链表的复制
  <a class="anchor" href="#138-%e9%9a%8f%e6%9c%ba%e9%93%be%e8%a1%a8%e7%9a%84%e5%a4%8d%e5%88%b6">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="148-排序链表">
  148. 排序链表
  <a class="anchor" href="#148-%e6%8e%92%e5%ba%8f%e9%93%be%e8%a1%a8">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="23-合并-k-个升序链表">
  23. 合并 K 个升序链表
  <a class="anchor" href="#23-%e5%90%88%e5%b9%b6-k-%e4%b8%aa%e5%8d%87%e5%ba%8f%e9%93%be%e8%a1%a8">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路1：我们已经实现了合并两个有序链表的函数，合并k个有序链表，也就扩展下就行了，但时间复杂度有点高，不过还是通过了，代码如下：</li>
<li>思路2：使用优先级队列（二叉堆），这个代码后面再补充，https://labuladong.github.io/algo/di-ling-zh-bfe1b/shuang-zhi-0f7cc/</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mergeKLists</span>(<span style="color:#a6e22e">lists</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">lists</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ret</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">node</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">lists</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ret</span> = <span style="color:#a6e22e">mergeTwoLists</span>(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">node</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mergeTwoLists</span>(<span style="color:#a6e22e">list1</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>, <span style="color:#a6e22e">list2</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">ListNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">list1</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">list2</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">list2</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">list1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">dummy</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ListNode</span>{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">nil</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cur</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dummy</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">list1</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">list2</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">list1</span>.<span style="color:#a6e22e">Val</span> &gt; <span style="color:#a6e22e">list2</span>.<span style="color:#a6e22e">Val</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">list2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">list2</span> = <span style="color:#a6e22e">list2</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">list1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">list1</span> = <span style="color:#a6e22e">list1</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cur</span> = <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">list1</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">list1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">list2</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">cur</span>.<span style="color:#a6e22e">Next</span> = <span style="color:#a6e22e">list2</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dummy</span>.<span style="color:#a6e22e">Next</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="二叉树">
  *二叉树
  <a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91">#</a>
</h2>
<p>  树的递归遍历，又称为深度优先DFS，分为动态规划解法和回溯算法的解法。树当然还有迭代遍历/层序遍历，也称为广度优先BFS。我会在下面的代码中尽可能提供多种解法，遇到树的问题，优先考虑动态规划，充分利用递归函数的返回值，如果涉及到向递归函数传参，那可优先将递归函数写成闭包，这样闭包内部也可只用外部的变量，不用传递指针，看起来可能会好理解点。</p>
<h3 id="94-二叉树的中序遍历">
  94. 二叉树的中序遍历
  <a class="anchor" href="#94-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：无</li>
<li>思路1：动态规划划分子问题。</li>
<li>思路2：回溯算法，写一个闭包作为遍历函数，闭包内可访问闭包外的ret</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 思路1，充分利用递归函数的返回值，不需要传递额外的指针。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">inorderTraversal</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) []<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ret</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span> = append(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">inorderTraversal</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>)<span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span> = append(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Val</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span> = append(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">inorderTraversal</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)<span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 思路2，采用闭包，闭包可以访问外部的变量，不需要传递额外的指针，感觉更好理解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">inorderTraversal</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) []<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ret</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ret</span> = append(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Val</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="104-二叉树的最大深度">
  104. 二叉树的最大深度
  <a class="anchor" href="#104-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：无</li>
<li>思路1：动态规划划分子问题，从整体的角度来解题，它当然也能定义额外的遍历函数，这个遍历函数通常有返回值且不需要额外的指针</li>
<li>思路2：回溯算法，记录每次遍历到的数据，是从局部的角度来解决问题，通常需要额外的遍历函数，这个遍历函数通常没有返回值，一般通过参数传入指针的形式来解题</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 思路1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 递归划分子问题的思想，采用了后续遍历，这是动态规划的思想，未借助额外的遍历函数，充分利用遍历函数maxDepth的返回值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义：给我一棵树，我就能返回这棵树的最大深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxDepth</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">maxDepth</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">maxDepth</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">right</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">right</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 思路2，用闭包，可以不用传参，闭包内部可以访问闭包外部的变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxDepth</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">depth</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">root1</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">root1</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root1</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">depth</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root1</span>.<span style="color:#a6e22e">Left</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">root1</span>.<span style="color:#a6e22e">Right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 到叶节点了，更新最大深度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">ret</span> = <span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">depth</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">root1</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">root1</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">depth</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">j</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="226-翻转二叉树">
  226. 翻转二叉树
  <a class="anchor" href="#226-%e7%bf%bb%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/invert-binary-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：无</li>
<li>思路1：动态规划划分子问题，递归函数invertTree有返回值</li>
<li>思路2：回溯算法</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 思路1：动态规划，充分利用遍历函数invertTree的返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 定义：给我一棵树，我就能返回这棵树的翻转二叉树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">invertTree</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">invertTree</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">invertTree</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span> = <span style="color:#a6e22e">right</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">left</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 思路2：回溯算法，定义无返回值的traverse。当然通常回溯算法需要传入额外的指针，回溯算法也能有返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">invertTree</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>, <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="101-对称二叉树">
  101. 对称二叉树
  <a class="anchor" href="#101-%e5%af%b9%e7%a7%b0%e4%ba%8c%e5%8f%89%e6%a0%91">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/symmetric-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：用递归，和迭代的思想解题</li>
<li>思路1：动态规划，定义有返回值的递归函数且不需要传入额外的指针，需要同时满足同一个根节点，左右子树对称就是对称二叉树。同一个根节点可向递归函数传递两个root即可。时空复杂度都是O(n)，空间复杂度指的是系统栈的调用</li>
<li>思路2：迭代，同样需要同时满足同一个根节点，左右子树对称就是对称二叉树。将递归程序改成迭代程序通常会用到一个队列，初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。可以发现思路1更优雅。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 思路1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isSymmetric</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">root</span>,<span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">root1</span>, <span style="color:#a6e22e">root2</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root1</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">root2</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root1</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">root2</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root1</span>.<span style="color:#a6e22e">Val</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">root2</span>.<span style="color:#a6e22e">Val</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">root1</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">root2</span>.<span style="color:#a6e22e">Right</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">root1</span>.<span style="color:#a6e22e">Right</span>, <span style="color:#a6e22e">root2</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 思路2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isSymmetric</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这种写法包含了两个root都是空的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">queue</span> <span style="color:#f92672">:=</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>{} <span style="color:#75715e">// 借助一个队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>,<span style="color:#a6e22e">root</span> <span style="color:#75715e">// 初始化两个节点，并将其放入队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">queue</span> = append(append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">p</span>), <span style="color:#a6e22e">q</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">queue</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span> = <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">queue</span> = <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">2</span>:] <span style="color:#75715e">// 出队两个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">q</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">q</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Val</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Val</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">queue</span> = append(append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Left</span>), <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">queue</span> = append(append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">Right</span>), <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="543-二叉树的直径">
  543. 二叉树的直径
  <a class="anchor" href="#543-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e7%9b%b4%e5%be%84">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：回溯算法，需要通过maxDepth函数求出子树的最大深度，这个回溯需要返回值，需要传递额外的指针。遇到树问题，首先想到的是给函数设置返回值，然后在后序位置做文章。这个问题貌似也能看做是动态规划的问题，问题分解：一棵树的直径 = max(左子树的最大深度+右子树的最大深度)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">diameterOfBinaryTree</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">maxDiameter</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">maxDepth</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">maxDepth</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">leftDepth</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">maxDepth</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rightDepth</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">maxDepth</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">curDepth</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">leftDepth</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">rightDepth</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">curDepth</span> &gt; <span style="color:#a6e22e">maxDiameter</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">maxDiameter</span> = <span style="color:#a6e22e">curDepth</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">leftDepth</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">rightDepth</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">leftDepth</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rightDepth</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">maxDepth</span>(<span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">maxDiameter</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="102-二叉树的层序遍历">
  102. 二叉树的层序遍历
  <a class="anchor" href="#102-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：无</li>
<li>思路：这是一种迭代遍历的思路，通常递归问题转迭代问题时，都需要引入一个队列queue来处理。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">levelOrder</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) [][]<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ret</span> [][]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">queue</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">queue</span> = append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> len(<span style="color:#a6e22e">queue</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">level</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">length</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">queue</span>) <span style="color:#75715e">// queue的长度会变，需要用变量单独记录，不然level的结果不对
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span>&lt;<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">node</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">queue</span> = <span style="color:#a6e22e">queue</span>[<span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">level</span> = append(<span style="color:#a6e22e">level</span>, <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">queue</span> = append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">queue</span> = append(<span style="color:#a6e22e">queue</span>, <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">level</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ret</span> = append(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">level</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="108-将有序数组转换为二叉搜索树">
  108. 将有序数组转换为二叉搜索树
  <a class="anchor" href="#108-%e5%b0%86%e6%9c%89%e5%ba%8f%e6%95%b0%e7%bb%84%e8%bd%ac%e6%8d%a2%e4%b8%ba%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：无</li>
<li>思路：二叉搜索树的中序遍历是升序序列。动态规划，将问题划分为：中间节点+左右子树的问题，模仿二分查找的思路，二分地找数组的中间节点，递归地将该节点作为根节点，把左边给左边的树，右边给右边的树。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sortedArrayToBST</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">nums</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">nums</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">nums</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">left</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">right</span> <span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> &gt; <span style="color:#a6e22e">right</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">middle</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">left</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">right</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">root</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">TreeNode</span>{<span style="color:#a6e22e">Val</span>:<span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">middle</span>]}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span> = <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">nums</span>, <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">middle</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">nums</span>, <span style="color:#a6e22e">middle</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">right</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="98-验证二叉搜索树">
  98. 验证二叉搜索树
  <a class="anchor" href="#98-%e9%aa%8c%e8%af%81%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：无</li>
<li>思路：动态规划，二叉搜索树的性质：根节点的值都大于左子树的值，并且根节点的值都小于右子树的值。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isValidBST</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">root</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MinInt</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>, <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Val</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> &gt; <span style="color:#a6e22e">left</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">x</span> &lt; <span style="color:#a6e22e">right</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">x</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">traverse</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">right</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="230-二叉搜索树中第k小的元素">
  230. 二叉搜索树中第K小的元素
  <a class="anchor" href="#230-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%ac%ack%e5%b0%8f%e7%9a%84%e5%85%83%e7%b4%a0">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：无</li>
<li>思路：中序遍历就是有序数组，直接返回下标为k-1的那个值</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">kthSmallest</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ss</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ss</span> = append(<span style="color:#a6e22e">ss</span>, <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Val</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ss</span>[<span style="color:#a6e22e">k</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="199-二叉树的右视图">
  199. 二叉树的右视图
  <a class="anchor" href="#199-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%8f%b3%e8%a7%86%e5%9b%be">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：当前的深度大于结果的长度，才认为是需要添加到结果里面的，题目要求右视图，所以先递归右子树。当题目要求左视图，自然想到先递归左子树。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">rightSideView</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) []<span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ret</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">depth</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">depth</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">depth</span> &gt; len(<span style="color:#a6e22e">ret</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ret</span> = append(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">depth</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="114-二叉树展开为链表">
  114. 二叉树展开为链表
  <a class="anchor" href="#114-%e4%ba%8c%e5%8f%89%e6%a0%91%e5%b1%95%e5%bc%80%e4%b8%ba%e9%93%be%e8%a1%a8">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：链表的遍历结果应该与二叉树的前序遍历相同，结果依旧用树的节点表示链表，其中right指针指向链表中的下一个节点，left指针始终指向nil。</li>
<li>思路：动态规划，划分子问题，传递一棵树，返回一个链表。只需要考虑当前root节点应该怎么做，递归函数会自动遍历出所有节点。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">flatten</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>)  {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1、边界条件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2、逻辑处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 将左右子树展平为链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">flatten</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">flatten</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将左子树放在root的右子树上，并且把左子树置空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">left</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 把右子树挪到末尾，并将原来的右子树接上去
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">node</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">node</span> = <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">right</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 3、返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="105-从前序与中序遍历序列构造二叉树">
  105. 从前序与中序遍历序列构造二叉树
  <a class="anchor" href="#105-%e4%bb%8e%e5%89%8d%e5%ba%8f%e4%b8%8e%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：动态规划，找到前序的第一个节点在中序的位置，然后递归地根据根的位置调用buildTree，其定义是给我两个切片，我就能返回一棵树，给我左边的两个切片，我就返回左子树，给我右边的两个切片，我就返回右子树。如果题目变成了知道前序中序遍历，求后序遍历，那么只需要在本题的基础上，后续遍历这棵树并返回一个切片即可。知道前后序没法确定出中序，因为中序给了左右子树的位置信息。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buildTree</span>(<span style="color:#a6e22e">preorder</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">inorder</span> []<span style="color:#66d9ef">int</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">preorder</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> len(<span style="color:#a6e22e">inorder</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">root</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">inorder</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">preorder</span>[<span style="color:#ae81ff">0</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">root</span> = <span style="color:#a6e22e">k</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">TreeNode</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Val</span>: <span style="color:#a6e22e">preorder</span>[<span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Left</span>: <span style="color:#a6e22e">buildTree</span>(<span style="color:#a6e22e">preorder</span>[<span style="color:#ae81ff">1</span>: <span style="color:#a6e22e">root</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">inorder</span>[<span style="color:#ae81ff">0</span>:<span style="color:#a6e22e">root</span>]),
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Right</span>: <span style="color:#a6e22e">buildTree</span>(<span style="color:#a6e22e">preorder</span>[<span style="color:#a6e22e">root</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:],<span style="color:#a6e22e">inorder</span>[<span style="color:#a6e22e">root</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:]),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="437-路径总和-iii">
  437. 路径总和 III
  <a class="anchor" href="#437-%e8%b7%af%e5%be%84%e6%80%bb%e5%92%8c-iii">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</li>
<li>思路：前缀和+哈希，这是数组技巧里面的考点。这题得借鉴一下第一题，两数之和的思路，前缀和数组改用为前缀和map，key是前缀和，value是路径数目，也就是结果的一部分，采用回溯算法的思想。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pathSum</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>, <span style="color:#a6e22e">targetSum</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">prefixSum</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">1</span>} <span style="color:#75715e">// 初始化，前缀和为0的路径有1条。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>, <span style="color:#a6e22e">currentSum</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">ret</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>, <span style="color:#a6e22e">currentSum</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">ret</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">currentSum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cnt</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">prefixSum</span>[<span style="color:#a6e22e">currentSum</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">targetSum</span>]; <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ret</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">cnt</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">prefixSum</span>[<span style="color:#a6e22e">currentSum</span>]<span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ret</span> = <span style="color:#a6e22e">ret</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">currentSum</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>, <span style="color:#a6e22e">currentSum</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">prefixSum</span>[<span style="color:#a6e22e">currentSum</span>]<span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">root</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="236-二叉树的最近公共祖先">
  236. 二叉树的最近公共祖先
  <a class="anchor" href="#236-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：动态规划</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">lowestCommonAncestor</span>(<span style="color:#a6e22e">root</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">root</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">q</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">lowestCommonAncestor</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Left</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">lowestCommonAncestor</span>(<span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Right</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">q</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">left</span>
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">right</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="124-二叉树中的最大路径和">
  124. 二叉树中的最大路径和
  <a class="anchor" href="#124-%e4%ba%8c%e5%8f%89%e6%a0%91%e4%b8%ad%e7%9a%84%e6%9c%80%e5%a4%a7%e8%b7%af%e5%be%84%e5%92%8c">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：把节点值的大小看做贡献值，那么当前节点对树的贡献值=自身的值+max(左子树，右子树)，记录下每次递归的最大值。递归结束时，最大值就是树的最大路径和。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxPathSum</span>(<span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">maxSum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MinInt32</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">maxGain</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">maxGain</span> = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">node</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TreeNode</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">leftGain</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">maxGain</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Left</span>), <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rightGain</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">maxGain</span>(<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>), <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">currentSum</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">leftGain</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">rightGain</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">maxSum</span> = <span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">maxSum</span>, <span style="color:#a6e22e">currentSum</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Val</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">leftGain</span>, <span style="color:#a6e22e">rightGain</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">maxGain</span>(<span style="color:#a6e22e">root</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">maxSum</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxInt</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">j</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="图论">
  *图论
  <a class="anchor" href="#%e5%9b%be%e8%ae%ba">#</a>
</h2>
<h3 id="200-岛屿数量">
  200. 岛屿数量
  <a class="anchor" href="#200-%e5%b2%9b%e5%b1%bf%e6%95%b0%e9%87%8f">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="994-腐烂的橘子">
  994. 腐烂的橘子
  <a class="anchor" href="#994-%e8%85%90%e7%83%82%e7%9a%84%e6%a9%98%e5%ad%90">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/rotting-oranges/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="207-课程表">
  207. 课程表
  <a class="anchor" href="#207-%e8%af%be%e7%a8%8b%e8%a1%a8">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="208-实现-trie-前缀树">
  208. 实现 Trie (前缀树)
  <a class="anchor" href="#208-%e5%ae%9e%e7%8e%b0-trie-%e5%89%8d%e7%bc%80%e6%a0%91">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h2 id="回溯">
  *回溯
  <a class="anchor" href="#%e5%9b%9e%e6%ba%af">#</a>
</h2>
<h3 id="46-全排列">
  46. 全排列
  <a class="anchor" href="#46-%e5%85%a8%e6%8e%92%e5%88%97">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="78-子集">
  78. 子集
  <a class="anchor" href="#78-%e5%ad%90%e9%9b%86">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="17-电话号码的字母组合">
  17. 电话号码的字母组合
  <a class="anchor" href="#17-%e7%94%b5%e8%af%9d%e5%8f%b7%e7%a0%81%e7%9a%84%e5%ad%97%e6%af%8d%e7%bb%84%e5%90%88">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="39-组合总和">
  39. 组合总和
  <a class="anchor" href="#39-%e7%bb%84%e5%90%88%e6%80%bb%e5%92%8c">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="22-括号生成">
  22. 括号生成
  <a class="anchor" href="#22-%e6%8b%ac%e5%8f%b7%e7%94%9f%e6%88%90">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/generate-parentheses/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="79-单词搜索">
  79. 单词搜索
  <a class="anchor" href="#79-%e5%8d%95%e8%af%8d%e6%90%9c%e7%b4%a2">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="131-分割回文串">
  131. 分割回文串
  <a class="anchor" href="#131-%e5%88%86%e5%89%b2%e5%9b%9e%e6%96%87%e4%b8%b2">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="51-n-皇后">
  51. N 皇后
  <a class="anchor" href="#51-n-%e7%9a%87%e5%90%8e">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/n-queens/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h2 id="二分查找">
  *二分查找
  <a class="anchor" href="#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be">#</a>
</h2>
<h3 id="35-搜索插入位置">
  35. 搜索插入位置
  <a class="anchor" href="#35-%e6%90%9c%e7%b4%a2%e6%8f%92%e5%85%a5%e4%bd%8d%e7%bd%ae">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/search-insert-position/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="74-搜索二维矩阵">
  74. 搜索二维矩阵
  <a class="anchor" href="#74-%e6%90%9c%e7%b4%a2%e4%ba%8c%e7%bb%b4%e7%9f%a9%e9%98%b5">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="34-在排序数组中查找元素的第一个和最后一个位置">
  34. 在排序数组中查找元素的第一个和最后一个位置
  <a class="anchor" href="#34-%e5%9c%a8%e6%8e%92%e5%ba%8f%e6%95%b0%e7%bb%84%e4%b8%ad%e6%9f%a5%e6%89%be%e5%85%83%e7%b4%a0%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%92%8c%e6%9c%80%e5%90%8e%e4%b8%80%e4%b8%aa%e4%bd%8d%e7%bd%ae">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="33搜索旋转排序数组">
  33.搜索旋转排序数组
  <a class="anchor" href="#33%e6%90%9c%e7%b4%a2%e6%97%8b%e8%bd%ac%e6%8e%92%e5%ba%8f%e6%95%b0%e7%bb%84">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：请设计一个时间复杂度为O(logN)的算法解决此问题。</li>
<li>思路：将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环。判断target在不在有序数组里，只需要比较最小值和最大值即可，如果target不在顺序区间，那么便去乱序区间，在其中再分割出有序区间。如果有序区间中有target那便好说，直接二分便可获得答案</li>
<li>例子：// [4, 5, 6, 7, 8, 9, 1, 2, 3], 3  第一次循环左边有序     // [7, 8, 9, 1, 2, 3, 4, 5, 6], 3  第一次循环右边有序</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">search</span>(<span style="color:#a6e22e">nums</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">target</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">middle</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, len(<span style="color:#a6e22e">nums</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">left</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">right</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">middle</span> = (<span style="color:#a6e22e">left</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">right</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">middle</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">target</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">middle</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 判断哪边有序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">left</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">middle</span>] {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 左边有序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">left</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">target</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">target</span> &lt; <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">middle</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 目标值在这个有序区间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">right</span> = <span style="color:#a6e22e">middle</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 目标值在这个无序区间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">left</span> = <span style="color:#a6e22e">middle</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 右边有序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">middle</span>] &lt; <span style="color:#a6e22e">target</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">target</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">nums</span>[<span style="color:#a6e22e">right</span>] {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 目标值在这个有序区间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">left</span> = <span style="color:#a6e22e">middle</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 目标值在这个无序区间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">right</span> = <span style="color:#a6e22e">middle</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="153-寻找旋转排序数组中的最小值">
  153. 寻找旋转排序数组中的最小值
  <a class="anchor" href="#153-%e5%af%bb%e6%89%be%e6%97%8b%e8%bd%ac%e6%8e%92%e5%ba%8f%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e6%9c%80%e5%b0%8f%e5%80%bc">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="4-寻找两个正序数组的中位数">
  4. 寻找两个正序数组的中位数
  <a class="anchor" href="#4-%e5%af%bb%e6%89%be%e4%b8%a4%e4%b8%aa%e6%ad%a3%e5%ba%8f%e6%95%b0%e7%bb%84%e7%9a%84%e4%b8%ad%e4%bd%8d%e6%95%b0">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h2 id="栈">
  *栈
  <a class="anchor" href="#%e6%a0%88">#</a>
</h2>
<h3 id="20-有效的括号">
  20. 有效的括号
  <a class="anchor" href="#20-%e6%9c%89%e6%95%88%e7%9a%84%e6%8b%ac%e5%8f%b7">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：用一个栈，需要左括号入栈，遇到右括号就取栈顶元素，看是不是能匹配上，不能匹配则直接返回false，最后栈空则是有效的括号，否则不是。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isValid</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">s</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> len(<span style="color:#a6e22e">s</span>)<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">byte</span>]<span style="color:#66d9ef">byte</span>{<span style="color:#e6db74">&#39;)&#39;</span>: <span style="color:#e6db74">&#39;(&#39;</span>, <span style="color:#e6db74">&#39;]&#39;</span>: <span style="color:#e6db74">&#39;[&#39;</span>, <span style="color:#e6db74">&#39;}&#39;</span>: <span style="color:#e6db74">&#39;{&#39;</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">stack</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">byte</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;[&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;{&#39;</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">stack</span> = append(<span style="color:#a6e22e">stack</span>, byte(<span style="color:#a6e22e">value</span>))
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">stack</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> { <span style="color:#75715e">// 防止这种括号 }{
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">top</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">stack</span>[len(<span style="color:#a6e22e">stack</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">stack</span> = <span style="color:#a6e22e">stack</span>[:len(<span style="color:#a6e22e">stack</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span>[byte(<span style="color:#a6e22e">value</span>)] <span style="color:#f92672">!=</span> <span style="color:#a6e22e">top</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">stack</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="155-最小栈">
  155. 最小栈
  <a class="anchor" href="#155-%e6%9c%80%e5%b0%8f%e6%a0%88">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/min-stack/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：在常数时间内检索到最小元素的栈。</li>
<li>思路：主栈主要用于实现push,pop和pop函数，辅助栈主要用于记录每次的最小值，保证栈顶元素始终是最小值即可，两个栈的长度是一致的，同时操作即可，很简单</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MinStack</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">stack</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">minStack</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Constructor</span>() <span style="color:#a6e22e">MinStack</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">MinStack</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">stack</span>: []<span style="color:#66d9ef">int</span>{},
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">minStack</span>: []<span style="color:#66d9ef">int</span>{},
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MinStack</span>) <span style="color:#a6e22e">Push</span>(<span style="color:#a6e22e">val</span> <span style="color:#66d9ef">int</span>)  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">stack</span> = append(<span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">stack</span>, <span style="color:#a6e22e">val</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">minStack</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">minStack</span> = append(<span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">minStack</span>, <span style="color:#a6e22e">val</span>)
</span></span><span style="display:flex;"><span>    }<span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">top</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">minStack</span>[len(<span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">minStack</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]  
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">minStack</span> = append(<span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">minStack</span>, <span style="color:#a6e22e">minInt</span>(<span style="color:#a6e22e">top</span>,<span style="color:#a6e22e">val</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">minInt</span>(<span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">j</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MinStack</span>) <span style="color:#a6e22e">Pop</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">stack</span>) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">stack</span> = <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">stack</span>[:len(<span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">stack</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">minStack</span> = <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">minStack</span>[:len(<span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">minStack</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MinStack</span>) <span style="color:#a6e22e">Top</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">stack</span>) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">stack</span>[len(<span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">stack</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">this</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MinStack</span>) <span style="color:#a6e22e">GetMin</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">minStack</span>) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">minStack</span>[len(<span style="color:#a6e22e">this</span>.<span style="color:#a6e22e">minStack</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxInt</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="394-字符串解码">
  394. 字符串解码
  <a class="anchor" href="#394-%e5%ad%97%e7%ac%a6%e4%b8%b2%e8%a7%a3%e7%a0%81">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：可认为所有的输入均为合法输入</li>
<li>思路：用两个栈，一个用于存数字，一个用于存字母，遇到左括号数字和结果ret均入栈后，将其置为对应的零值，遇到右括号数字和ret均出站，并构建新的结果，仅仅遇到字母，则直接构建新的结果。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">decodeString</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">s</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">numStack</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">strStack</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">num</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>  <span style="color:#75715e">// 用于累积读取完整数字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#75715e">// 用于累积当前解码的字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">char</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">char</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;0&#39;</span>, <span style="color:#e6db74">&#39;1&#39;</span>, <span style="color:#e6db74">&#39;2&#39;</span>, <span style="color:#e6db74">&#39;3&#39;</span>, <span style="color:#e6db74">&#39;4&#39;</span>, <span style="color:#e6db74">&#39;5&#39;</span>, <span style="color:#e6db74">&#39;6&#39;</span>, <span style="color:#e6db74">&#39;7&#39;</span>, <span style="color:#e6db74">&#39;8&#39;</span>, <span style="color:#e6db74">&#39;9&#39;</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(string(<span style="color:#a6e22e">char</span>))
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">num</span> = <span style="color:#a6e22e">num</span><span style="color:#f92672">*</span><span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;[&#39;</span>: <span style="color:#75715e">// 当遇到左括号，表示一个新的编码字符串开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">strStack</span> = append(<span style="color:#a6e22e">strStack</span>, <span style="color:#a6e22e">ret</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ret</span> = <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#75715e">// 重置数字和字符串，以便处理新的编码字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">numStack</span> = append(<span style="color:#a6e22e">numStack</span>, <span style="color:#a6e22e">num</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">num</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;]&#39;</span>: <span style="color:#75715e">// 当遇到右括号，表示当前编码字符串结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">count</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">numStack</span>[len(<span style="color:#a6e22e">numStack</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">numStack</span> = <span style="color:#a6e22e">numStack</span>[:len(<span style="color:#a6e22e">numStack</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">str</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strStack</span>[len(<span style="color:#a6e22e">strStack</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">strStack</span> = <span style="color:#a6e22e">strStack</span>[:len(<span style="color:#a6e22e">strStack</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ret</span> = <span style="color:#a6e22e">str</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Repeat</span>(<span style="color:#a6e22e">ret</span>, <span style="color:#a6e22e">count</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">default</span>: <span style="color:#75715e">// 当遇到字母时，直接添加到当前字符串中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">ret</span> <span style="color:#f92672">+=</span> string(<span style="color:#a6e22e">char</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="739-每日温度">
  739. 每日温度
  <a class="anchor" href="#739-%e6%af%8f%e6%97%a5%e6%b8%a9%e5%ba%a6">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：题目和顺序有关，可以考虑单调栈，二分，堆，排序这些技巧，挨个想，总有一个是对的，本题我们采用单调栈的思想。</li>
</ul>
<h3 id="84-柱状图中最大的矩形">
  84. 柱状图中最大的矩形
  <a class="anchor" href="#84-%e6%9f%b1%e7%8a%b6%e5%9b%be%e4%b8%ad%e6%9c%80%e5%a4%a7%e7%9a%84%e7%9f%a9%e5%bd%a2">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h2 id="堆">
  *堆
  <a class="anchor" href="#%e5%a0%86">#</a>
</h2>
<h3 id="215-数组中的第k个最大元素">
  215. 数组中的第K个最大元素
  <a class="anchor" href="#215-%e6%95%b0%e7%bb%84%e4%b8%ad%e7%9a%84%e7%ac%ack%e4%b8%aa%e6%9c%80%e5%a4%a7%e5%85%83%e7%b4%a0">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="347-前-k-个高频元素">
  347. 前 K 个高频元素
  <a class="anchor" href="#347-%e5%89%8d-k-%e4%b8%aa%e9%ab%98%e9%a2%91%e5%85%83%e7%b4%a0">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/top-k-frequent-elements/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="295-数据流的中位数">
  295. 数据流的中位数
  <a class="anchor" href="#295-%e6%95%b0%e6%8d%ae%e6%b5%81%e7%9a%84%e4%b8%ad%e4%bd%8d%e6%95%b0">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/find-median-from-data-stream/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h2 id="贪心算法">
  *贪心算法
  <a class="anchor" href="#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95">#</a>
</h2>
<h3 id="121-买卖股票的最佳时机">
  121. 买卖股票的最佳时机
  <a class="anchor" href="#121-%e4%b9%b0%e5%8d%96%e8%82%a1%e7%a5%a8%e7%9a%84%e6%9c%80%e4%bd%b3%e6%97%b6%e6%9c%ba">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="55-跳跃游戏">
  55. 跳跃游戏
  <a class="anchor" href="#55-%e8%b7%b3%e8%b7%83%e6%b8%b8%e6%88%8f">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="45-跳跃游戏-ii">
  45. 跳跃游戏 II
  <a class="anchor" href="#45-%e8%b7%b3%e8%b7%83%e6%b8%b8%e6%88%8f-ii">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="763-划分字母区间">
  763. 划分字母区间
  <a class="anchor" href="#763-%e5%88%92%e5%88%86%e5%ad%97%e6%af%8d%e5%8c%ba%e9%97%b4">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/partition-labels/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h2 id="动态规划">
  *动态规划
  <a class="anchor" href="#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#</a>
</h2>
<h3 id="70-爬楼梯">
  70. 爬楼梯
  <a class="anchor" href="#70-%e7%88%ac%e6%a5%bc%e6%a2%af">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="118-杨辉三角">
  118. 杨辉三角
  <a class="anchor" href="#118-%e6%9d%a8%e8%be%89%e4%b8%89%e8%a7%92">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/pascals-triangle/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="198-打家劫舍">
  198. 打家劫舍
  <a class="anchor" href="#198-%e6%89%93%e5%ae%b6%e5%8a%ab%e8%88%8d">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="279-完全平方数">
  279. 完全平方数
  <a class="anchor" href="#279-%e5%ae%8c%e5%85%a8%e5%b9%b3%e6%96%b9%e6%95%b0">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="322-零钱兑换">
  322. 零钱兑换
  <a class="anchor" href="#322-%e9%9b%b6%e9%92%b1%e5%85%91%e6%8d%a2">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="139-单词拆分">
  139. 单词拆分
  <a class="anchor" href="#139-%e5%8d%95%e8%af%8d%e6%8b%86%e5%88%86">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/word-break/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="300-最长递增子序列">
  300. 最长递增子序列
  <a class="anchor" href="#300-%e6%9c%80%e9%95%bf%e9%80%92%e5%a2%9e%e5%ad%90%e5%ba%8f%e5%88%97">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="152-乘积最大子数组">
  152. 乘积最大子数组
  <a class="anchor" href="#152-%e4%b9%98%e7%a7%af%e6%9c%80%e5%a4%a7%e5%ad%90%e6%95%b0%e7%bb%84">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="416-分割等和子集">
  416. 分割等和子集
  <a class="anchor" href="#416-%e5%88%86%e5%89%b2%e7%ad%89%e5%92%8c%e5%ad%90%e9%9b%86">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="32-最长有效括号">
  32. 最长有效括号
  <a class="anchor" href="#32-%e6%9c%80%e9%95%bf%e6%9c%89%e6%95%88%e6%8b%ac%e5%8f%b7">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/longest-valid-parentheses/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h2 id="多维动态规划">
  *多维动态规划
  <a class="anchor" href="#%e5%a4%9a%e7%bb%b4%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#</a>
</h2>
<h3 id="62-不同路径">
  62. 不同路径
  <a class="anchor" href="#62-%e4%b8%8d%e5%90%8c%e8%b7%af%e5%be%84">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/unique-paths/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="64-最小路径和">
  64. 最小路径和
  <a class="anchor" href="#64-%e6%9c%80%e5%b0%8f%e8%b7%af%e5%be%84%e5%92%8c">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/minimum-path-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="5-最长回文子串">
  5. 最长回文子串
  <a class="anchor" href="#5-%e6%9c%80%e9%95%bf%e5%9b%9e%e6%96%87%e5%ad%90%e4%b8%b2">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/longest-palindromic-substring/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：首先明确一下，回文串就是正着读和反着读都一样的字符串，判断回文串很简单，用左右指针相向而行就行了，而且不需要考虑是奇数还是偶数。但寻找最长回文子串，需要考虑奇数还是偶数，同样采取左右指针，但这个左右指针是相背而行，从中间向两端搜索。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">longestPalindrome</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">res</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">s</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 以 s[i] 为中心的最长回文子串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">s1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">palindrome</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 以 s[i] 和 s[i+1] 为中心的最长回文子串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">palindrome</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">maxLenOfString</span>(<span style="color:#a6e22e">res</span>,<span style="color:#a6e22e">s1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">res</span> = <span style="color:#a6e22e">maxLenOfString</span>(<span style="color:#a6e22e">res</span>,<span style="color:#a6e22e">s2</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">res</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">palindrome</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">l</span>, <span style="color:#a6e22e">r</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">l</span> &gt; <span style="color:#a6e22e">r</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">l</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">r</span> &lt; len(<span style="color:#a6e22e">s</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">l</span>] <span style="color:#f92672">==</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">r</span>] {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">l</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">r</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">l</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> : <span style="color:#a6e22e">r</span>] <span style="color:#75715e">// 本来r也要减减，但由于是左闭右开的区间，所以刚好不用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">maxLenOfString</span>(<span style="color:#a6e22e">s1</span>, <span style="color:#a6e22e">s2</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">s1</span>) <span style="color:#f92672">&gt;=</span> len(<span style="color:#a6e22e">s2</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s2</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="1143-最长公共子序列">
  1143. 最长公共子序列
  <a class="anchor" href="#1143-%e6%9c%80%e9%95%bf%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/longest-common-subsequence/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="72-编辑距离">
  72. 编辑距离
  <a class="anchor" href="#72-%e7%bc%96%e8%be%91%e8%b7%9d%e7%a6%bb">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/edit-distance/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h2 id="技巧">
  *技巧
  <a class="anchor" href="#%e6%8a%80%e5%b7%a7">#</a>
</h2>
<h3 id="136-只出现一次的数字">
  136. 只出现一次的数字
  <a class="anchor" href="#136-%e5%8f%aa%e5%87%ba%e7%8e%b0%e4%b8%80%e6%ac%a1%e7%9a%84%e6%95%b0%e5%ad%97">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="169-多数元素">
  169. 多数元素
  <a class="anchor" href="#169-%e5%a4%9a%e6%95%b0%e5%85%83%e7%b4%a0">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="75-颜色分类">
  75. 颜色分类
  <a class="anchor" href="#75-%e9%a2%9c%e8%89%b2%e5%88%86%e7%b1%bb">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/sort-colors/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="31-下一个排列">
  31. 下一个排列
  <a class="anchor" href="#31-%e4%b8%8b%e4%b8%80%e4%b8%aa%e6%8e%92%e5%88%97">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/next-permutation/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
<h3 id="287-寻找重复数">
  287. 寻找重复数
  <a class="anchor" href="#287-%e5%af%bb%e6%89%be%e9%87%8d%e5%a4%8d%e6%95%b0">#</a>
</h3>
<ul>
<li>地址：<a href="https://leetcode.cn/problems/find-the-duplicate-number/description/?envType=study-plan-v2&amp;envId=top-100-liked">传送门</a></li>
<li>要求：</li>
<li>思路：</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#哈希">*哈希</a>
      <ul>
        <li><a href="#1两数之和">1.两数之和</a></li>
        <li><a href="#49字母异位词分组">49.字母异位词分组</a></li>
        <li><a href="#128最长连续序列">128.最长连续序列</a></li>
      </ul>
    </li>
    <li><a href="#双指针">*双指针</a>
      <ul>
        <li><a href="#283移动零">283.移动零</a></li>
        <li><a href="#11盛最多水的容器">11.盛最多水的容器</a></li>
        <li><a href="#15三数之和">15.三数之和</a></li>
        <li><a href="#42接雨水">42.接雨水</a></li>
      </ul>
    </li>
    <li><a href="#滑动窗口">*滑动窗口</a>
      <ul>
        <li><a href="#3无重复字符的最长子串">3.无重复字符的最长子串</a></li>
        <li><a href="#438找到字符串中所有字母异位词">438.找到字符串中所有字母异位词</a></li>
      </ul>
    </li>
    <li><a href="#子串">*子串</a>
      <ul>
        <li><a href="#560和为k的子数组">560.和为K的子数组</a></li>
        <li><a href="#239滑动窗口最大值">239.滑动窗口最大值</a></li>
        <li><a href="#76最小覆盖子串">76.最小覆盖子串</a></li>
      </ul>
    </li>
    <li><a href="#普通数组">*普通数组</a>
      <ul>
        <li><a href="#53最大子数组和">53.最大子数组和</a></li>
        <li><a href="#56合并区间">56.合并区间</a></li>
        <li><a href="#189轮转数组">189.轮转数组</a></li>
        <li><a href="#238除自身以外数组的乘积">238.除自身以外数组的乘积</a></li>
        <li><a href="#41缺失的第一个正数">41.缺失的第一个正数</a></li>
      </ul>
    </li>
    <li><a href="#矩阵">*矩阵</a>
      <ul>
        <li><a href="#73矩阵置零">73.矩阵置零</a></li>
        <li><a href="#54螺旋矩阵">54.螺旋矩阵</a></li>
        <li><a href="#48旋转图像">48.旋转图像</a></li>
        <li><a href="#240搜索二维矩阵ii">240.搜索二维矩阵II</a></li>
      </ul>
    </li>
    <li><a href="#链表">*链表</a>
      <ul>
        <li><a href="#160-相交链表">160. 相交链表</a></li>
        <li><a href="#206反转链表">206.反转链表</a></li>
        <li><a href="#146lru缓存">146.LRU缓存</a></li>
        <li><a href="#234-回文链表">234. 回文链表</a></li>
        <li><a href="#141-环形链表">141. 环形链表</a></li>
        <li><a href="#142-环形链表-ii">142. 环形链表 II</a></li>
        <li><a href="#21-合并两个有序链表">21. 合并两个有序链表</a></li>
        <li><a href="#2-两数相加">2. 两数相加</a></li>
        <li><a href="#19-删除链表的倒数第-n-个结点">19. 删除链表的倒数第 N 个结点</a></li>
        <li><a href="#24-两两交换链表中的节点">24. 两两交换链表中的节点</a></li>
        <li><a href="#25-k-个一组翻转链表">25. K 个一组翻转链表</a></li>
        <li><a href="#138-随机链表的复制">138. 随机链表的复制</a></li>
        <li><a href="#148-排序链表">148. 排序链表</a></li>
        <li><a href="#23-合并-k-个升序链表">23. 合并 K 个升序链表</a></li>
      </ul>
    </li>
    <li><a href="#二叉树">*二叉树</a>
      <ul>
        <li><a href="#94-二叉树的中序遍历">94. 二叉树的中序遍历</a></li>
        <li><a href="#104-二叉树的最大深度">104. 二叉树的最大深度</a></li>
        <li><a href="#226-翻转二叉树">226. 翻转二叉树</a></li>
        <li><a href="#101-对称二叉树">101. 对称二叉树</a></li>
        <li><a href="#543-二叉树的直径">543. 二叉树的直径</a></li>
        <li><a href="#102-二叉树的层序遍历">102. 二叉树的层序遍历</a></li>
        <li><a href="#108-将有序数组转换为二叉搜索树">108. 将有序数组转换为二叉搜索树</a></li>
        <li><a href="#98-验证二叉搜索树">98. 验证二叉搜索树</a></li>
        <li><a href="#230-二叉搜索树中第k小的元素">230. 二叉搜索树中第K小的元素</a></li>
        <li><a href="#199-二叉树的右视图">199. 二叉树的右视图</a></li>
        <li><a href="#114-二叉树展开为链表">114. 二叉树展开为链表</a></li>
        <li><a href="#105-从前序与中序遍历序列构造二叉树">105. 从前序与中序遍历序列构造二叉树</a></li>
        <li><a href="#437-路径总和-iii">437. 路径总和 III</a></li>
        <li><a href="#236-二叉树的最近公共祖先">236. 二叉树的最近公共祖先</a></li>
        <li><a href="#124-二叉树中的最大路径和">124. 二叉树中的最大路径和</a></li>
      </ul>
    </li>
    <li><a href="#图论">*图论</a>
      <ul>
        <li><a href="#200-岛屿数量">200. 岛屿数量</a></li>
        <li><a href="#994-腐烂的橘子">994. 腐烂的橘子</a></li>
        <li><a href="#207-课程表">207. 课程表</a></li>
        <li><a href="#208-实现-trie-前缀树">208. 实现 Trie (前缀树)</a></li>
      </ul>
    </li>
    <li><a href="#回溯">*回溯</a>
      <ul>
        <li><a href="#46-全排列">46. 全排列</a></li>
        <li><a href="#78-子集">78. 子集</a></li>
        <li><a href="#17-电话号码的字母组合">17. 电话号码的字母组合</a></li>
        <li><a href="#39-组合总和">39. 组合总和</a></li>
        <li><a href="#22-括号生成">22. 括号生成</a></li>
        <li><a href="#79-单词搜索">79. 单词搜索</a></li>
        <li><a href="#131-分割回文串">131. 分割回文串</a></li>
        <li><a href="#51-n-皇后">51. N 皇后</a></li>
      </ul>
    </li>
    <li><a href="#二分查找">*二分查找</a>
      <ul>
        <li><a href="#35-搜索插入位置">35. 搜索插入位置</a></li>
        <li><a href="#74-搜索二维矩阵">74. 搜索二维矩阵</a></li>
        <li><a href="#34-在排序数组中查找元素的第一个和最后一个位置">34. 在排序数组中查找元素的第一个和最后一个位置</a></li>
        <li><a href="#33搜索旋转排序数组">33.搜索旋转排序数组</a></li>
        <li><a href="#153-寻找旋转排序数组中的最小值">153. 寻找旋转排序数组中的最小值</a></li>
        <li><a href="#4-寻找两个正序数组的中位数">4. 寻找两个正序数组的中位数</a></li>
      </ul>
    </li>
    <li><a href="#栈">*栈</a>
      <ul>
        <li><a href="#20-有效的括号">20. 有效的括号</a></li>
        <li><a href="#155-最小栈">155. 最小栈</a></li>
        <li><a href="#394-字符串解码">394. 字符串解码</a></li>
        <li><a href="#739-每日温度">739. 每日温度</a></li>
        <li><a href="#84-柱状图中最大的矩形">84. 柱状图中最大的矩形</a></li>
      </ul>
    </li>
    <li><a href="#堆">*堆</a>
      <ul>
        <li><a href="#215-数组中的第k个最大元素">215. 数组中的第K个最大元素</a></li>
        <li><a href="#347-前-k-个高频元素">347. 前 K 个高频元素</a></li>
        <li><a href="#295-数据流的中位数">295. 数据流的中位数</a></li>
      </ul>
    </li>
    <li><a href="#贪心算法">*贪心算法</a>
      <ul>
        <li><a href="#121-买卖股票的最佳时机">121. 买卖股票的最佳时机</a></li>
        <li><a href="#55-跳跃游戏">55. 跳跃游戏</a></li>
        <li><a href="#45-跳跃游戏-ii">45. 跳跃游戏 II</a></li>
        <li><a href="#763-划分字母区间">763. 划分字母区间</a></li>
      </ul>
    </li>
    <li><a href="#动态规划">*动态规划</a>
      <ul>
        <li><a href="#70-爬楼梯">70. 爬楼梯</a></li>
        <li><a href="#118-杨辉三角">118. 杨辉三角</a></li>
        <li><a href="#198-打家劫舍">198. 打家劫舍</a></li>
        <li><a href="#279-完全平方数">279. 完全平方数</a></li>
        <li><a href="#322-零钱兑换">322. 零钱兑换</a></li>
        <li><a href="#139-单词拆分">139. 单词拆分</a></li>
        <li><a href="#300-最长递增子序列">300. 最长递增子序列</a></li>
        <li><a href="#152-乘积最大子数组">152. 乘积最大子数组</a></li>
        <li><a href="#416-分割等和子集">416. 分割等和子集</a></li>
        <li><a href="#32-最长有效括号">32. 最长有效括号</a></li>
      </ul>
    </li>
    <li><a href="#多维动态规划">*多维动态规划</a>
      <ul>
        <li><a href="#62-不同路径">62. 不同路径</a></li>
        <li><a href="#64-最小路径和">64. 最小路径和</a></li>
        <li><a href="#5-最长回文子串">5. 最长回文子串</a></li>
        <li><a href="#1143-最长公共子序列">1143. 最长公共子序列</a></li>
        <li><a href="#72-编辑距离">72. 编辑距离</a></li>
      </ul>
    </li>
    <li><a href="#技巧">*技巧</a>
      <ul>
        <li><a href="#136-只出现一次的数字">136. 只出现一次的数字</a></li>
        <li><a href="#169-多数元素">169. 多数元素</a></li>
        <li><a href="#75-颜色分类">75. 颜色分类</a></li>
        <li><a href="#31-下一个排列">31. 下一个排列</a></li>
        <li><a href="#287-寻找重复数">287. 寻找重复数</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












